#+TITLE: Zetteldesk.el a Revision and Outlining tool built on top of Org-Roam

* Table of Contents                                                     :TOC:
- [[#introduction][Introduction]]
- [[#installation][Installation]]
- [[#debugging][Debugging]]
- [[#getting-started][Getting Started]]
  - [[#addingremoving-things-from-the-zetteldesk][Adding/Removing things from the Zetteldesk]]
  - [[#filter-functions][Filter Functions]]
  - [[#on-the-zetteldesk-scratch-buffer][On the zetteldesk-scratch buffer]]
  - [[#a-tour-of-the-predicate-functions][A tour of the predicate functions]]
- [[#a-sample-workflow][A Sample Workflow]]
- [[#keybindings][Keybindings]]

* Introduction
  Welcome to zetteldesk.el, a small library I wrote on top of Org-Roam. Now you may ask, why this was written and what purpose does it fulfill. Well, I am not sure, there are quite a lot of reasons I wanted to do this, I can't say I wrote it for one in specific. But there were two main ideas. The first being that I wanted some way to filter down my zettelkasten while doing revision for uni exams. Org-roam has a lot of tools by default to manage your nodes, even if you have a lot of them. But I needed some more to have a more frictionless revision. It came out pretty good, and I did very easy revision of all the topics I wanted, at the time of writing it. The second is a quote I read from "How to Take Smart Notes" that sparked an interest in my mind, and when I finally got the time to look into it, I made this. The two, despite divergent goals, were able to be combined very easily when I finally got to the end result. This introduction is going to be way longer than needed as I like writing stuff and I want to explain how this all came to be. You can skip it if you just want to learn how to use this, but I would recommend reading it, to have an "organic" introduction to the idea.

  So, while rereading the excellent book "How to Take Smart Notes" by Sonke Ahrens (around like 8-9 months after picking the workflow up) to have a more detailed look in some details I might have ignored starting out, I noticed that one interesting thing that was mentioned (would love to leave the very quote here but its been a few months and I am not in the mood of trying to find that exact sentence) was the idea of taking your zettels and spreading them on your desk to look at multiple of them at once. I started thinking about it and I wrote this idea in an org file. 
  
  #+begin_quote
    A desktop, is the top surface of a desk, or in the digital world an area in a computer screen in which some people arrange their icons, similarly to how they would arrange stuff in their desk. Now if I had an irl zettelkasten, I know for sure that my desktop would be filled with little notes with various topic when studying something. So why shouldn't I have a digital desktop where I can spread all my notes and look at them one by one, when studying. Wouldn't that be handy?
  #+end_quote

  Thus begun my planning of all this. I was originally gonna call this zettelkasten-desktop.el, but that one was quite large, so I just shortened it to zetteldesk.el.

  This started out really slowly with me thinking how I was gonna implement that idea and how it was all gonna pan out. I started with thinking of existing solutions for something similar. For example, I considered customising [[https://github.com/nex3/perspective-el][perspective.el]] to suit my needs as that had the ability of creating "perspectives" in which you can only view certain buffers. I quickly dropped that in favour of writing something from scratch. I felt that if I do it from scratch it would work out better as I would be more knowledgeable of what I am doing. Also, it was less work, because if I tried to customise a pre-existing package to suit my needs I would need to really go deep into learning what it does. I already had to do this for org-roam to write my addons to it, and as I am not a developer, have limited knowledge of elisp and also limited time to work on this, I thought it would be better if I wrote something from scratch using vanilla emacs and org-roam. Maybe I was wrong, but its fine, this has been working well so far for me.

  First thing I looked at was what kind of predicate I was gonna define and with what criteria I was going to filter things. I tried to follow a rather simple idea to do this and not overcomplicate things. Essentially, I define a buffer-local variable and give it a default value. Then I define the predicate function that shows when a buffer is part of the zettelkasten desktop. A buffer will be part of the desktop only if the value of that variable in the buffer is not equal to the default. I started planning out things by filtering buffers like this, but as I was going to use this with org-roam nodes as well, and for viewing nodes you are doing them a misservice if you do not use the commands defined from org-roam for traversing the database, I ported everything over to work with nodes as well learning a lot about the insides of org-roam in the process. There are probably a million other ways to make a simple user-friendly predicate, but changing the value of a buffer local variable seemed fairly easy to me so I went for it.
  
  When this was happening, I was in the second semester during which I took notes with org-roam and the zettelkasten method. I was proud to say that I had digitalised mostly everything I had notes for and had developed a good workflow for working with these notes (if anyone's interested on the workflow, some parts of it are described over on the part of my literate emacs config concerning Org-roam which you can find [[https://github.com/Vidianos-Giannitsis/Dotfiles/blob/master/emacs/.emacs.d/libs/zettelkasten.org][here]] and I might mention some things to explain some design choices and some functions I have defined). But after some time, the exam period was starting. Having worked on some of my intial ideas for this during the christmas holidays, I was done with the basic filter functions for switch-to-buffer and org-roam-node-find filtered down to only show the buffers/nodes I selected. I was really happy with them, but I didn't really know how to continue after that. Then, I realised two important things

1. My zettelkasten, having grown a lot more since the only other exam period I had used it in, was a bit harder to navigate so that I could do my revision in it.
2. The ideas I was considering with the zetteldesk, might be able to help with that.

  So I started thinking how I could combine these two. Having ran out of ideas for things to do, I thought trying to automate my revision process would be a fun puzzle. I had also not implemented the original idea, not having an idea of how I was gonna do it, but I said lets move on and I will think of something. I defined a new way of adding files to the zetteldesk besides a single buffer or a single node. That was to add a node and all its backlinks. As someone who works with big index files to sort their topics, this was very helpful, as I could add the majority of notes on a subject with a single command. Being able to have an org-roam-node-find function that shows only the nodes I am interested in, combined with org-roam UI, graphing that, was already a powerful tool. But there was basically no automation, nor had I achieved my original idea yet. All I had was a makeshift tool to filter my switch-to-buffer and org-roam-node-find to specific things. That was useful, but I wasn't really satisfied, I had to keep going. While doing revision for the first lesson, I noted down everything I did in a seperate file and was then thinking how I could automate it.

  Slowly, things started coming together. I crafted a workflow which significantly eased revision for university and also managed to implement, at least as best I could, my original vision. Then I experimented a bit more. If this came out good, which it was looking to be so, I could use it for more general purpose studying. Therefore, I needed to handle org-files that were outside the org-roam directory, material handed in pdf form, web content and I even setup a way to handle Info buffers (as I read a lot of documentation through those and I figured it might be a good idea). I have used this for every exam of my current semester as of writing this (February 2022) and it has worked wonders to help me revise everything. Obviously, this is only good revision if the notes themselves are good, but having spent quite a bit of time during the semester trying to understand the topics and make good notes about them, I didn't fear about that part. And the system's automation works to help the process of reviewing only the notes I want in a lot of way.

  And as in the buffer that puts all of this together, I sort things with headings, I thought that maybe this could also be used as an outliner tool. I will look at how people do those and implement some stuff specifically for that, but for now, its not here. I think it might be usable for that purpose though anyways.

  This is where we currently are. The main other thing I want to do for this, is to play around a bit with [[https://github.com/nobiot/org-remark][org-remark]]. I believe that in such tool, the ability to highlight things and add margin notes to it might be really useful. In general I do not really use this right now, so it will take some time to do that, but I look forward to it. I also add small things to it in a rather regular basis, whenever I feel something is missing. The development of this, is very closely connected with my studying, so if I find something I can improve I will try to do so.

  And after this incredibly long, and possibly unnecessarily detailed introduction lets dive into what this package does.

* Installation
  This package is currently not on MELPA. If people like it I will try to upload it, but for now I just wanted to publish the workflow I built for my exams, in case it is useful to others. To install this, simply clone this repository locally and add zetteldesk.el to your load-path.

  For instructions on how to do that, refer to https://www.emacswiki.org/emacs/LoadPath 
  
* Debugging
  This code is tested only on my machine, so there may be unexpected errors. If you find one, I would appreciate if you filed an issue about it. But before doing that, make sure you try reproducing it with emacs -Q. In this repository, you can find a debug.el file, if you load this, in an emacs -Q window you should have the minimal config in which this package will work. With that, try to reproduce your problem, to help me find out your issue.

  For loading debug.el during boot, I personally use the shortcut below. The -l flag makes emacs load an arbitrary lisp file on boot, so it works very well here. ~/Zetteldesk/ is my local copy of the git repo.

  #+BEGIN_SRC sh
    emacs -Q -l "~/Zetteldesk/debug.el"
  #+END_SRC
  
* Getting Started
  This section is supposed to be the short documentation of the package. Its supposed to be an introduction to you, the person who found this randomly on the internet, so you can dive in. I will eventually also write detailed documentation for the package, which I will export to texinfo format for viewing inside emacs, but for now, for details you can check the docstrings of all the functions as I have tried to document all the functions I write with a lot of detail. If you C-h f on any of the zetteldesk functions you will see a good amount of documentation. This is definitely not a finished product, but its good enough to get you started probably. 
  
** Adding/Removing things from the Zetteldesk
   There are a few primary ways to add someting to the Zetteldesk. The first two are rather obvious. Prompt for a buffer using ~zetteldesk-add-to-desktop~ or prompt for a node using ~zetteldesk-add-node-to-desktop~ and add it to the zetteldesk. Then, I have defined to ways to add a node's backlinks to the zetteldesk. One is to add a node and all its backlinks with ~zetteldesk-add-backlinks-to-desktop~. The other (~zetteldesk-add-poi-or-moc-backlink-to-desktop~) prompts the user for a node that has either the MOC or POI tag, then prompts them to select one of its backlinks and add that to the zetteldesk. The reason it doesn't show all nodes is because I use MOCs and POIs for indexes and important topics respectively, so typically they are the ones that have a lot of backlinks. Its rare that a "densely" linked node would not have one of these tags, so if I want to look at the backlinks of a node, it probably has one of these tags. And more filtering helps. As I explained in the intro, I work with index files for most of my topics. So adding all files under a certain index, or a single file under an index is certainly useful. Obviously the same things are implemented for removing buffers/nodes (check the functions ~zetteldesk-remove-from-desktop~, ~zetteldesk-remove-node-from-desktop~ and ~zetteldesk-remove-backlinks-from-desktop~). ~zetteldesk-add-moc-or-poi-backlink-to-desktop~ doesn't have a matching removing functions as I deemed it unnecessary. If you want to remove a node, you probably don't care if its the backlink of another node, so you can just use ~zetteldesk-remove-node-from-desktop~. Lastly, there is info buffers. It has always annoyed me how there is not a very clear way (at least one that I know of, there might be one, as all the backbone needed for something like that is in the Info program's source code) for saving specific info nodes and being able to switch between them faster. The info buffer is a persistent buffer so the buffer-local shenanigans used in the others don't work in it. But it wasn't that hard to do this. All you need to worry about is that if you run ~zetteldesk-add-info-node-to-desktop~ when on an info node, that node will be added to the zetteldesk. Similarly ~zetteldesk-remove-info-node-from-desktop~ prompts you to select an info node you added to the desktop and removes it from it. 
   
** Filter Functions
   The 4 primary interactive functions I have defined which are filtered version of the originals are ~zetteldesk-switch-to-buffer~ for a filtered ~switch-to-buffer~, ~zetteldesk-node-find~ for a filtered ~org-roam-node-find~, ~zetteldesk-node-insert~ for a filtered ~org-roam-node-insert~ and ~zetteldesk-info-goto-node~ for a filtered ~Info-goto-node~. Their use is I would say self explanatory because you probably already use these functions a lot. Ok maybe you don't use ~Info-goto-node~ every day. So what, I would say that if you use this, you will realise its pretty easy though. It just shows you a list of info nodes that are part of the zetteldeskm you select one and it magically takes you to that very node on the info program. But the rest are just filtered to only show buffers in the zetteldesk. One thing worth pointing out is that ~zetteldesk-switch-to-buffer~ does not display org-roam buffers, as I personally do not think its practical to use it for that. Its for buffers in the zetteldesk that are not nodes. There is also a complimentary function to ~zetteldesk-node-insert~, ~zetteldesk-node-insert-sort-backlinks~, which as the name suggests, sorts stuff by the number of backlinks they have and then has similar behaviour to ~zetteldesk-node-insert~. This is more of a convenience function for me to be used in conjuction with ~zetteldesk-insert-node-if-poi-or-moc~, which is explained below. Later on in this doc, I also explain all the predicate functions existing in the package so you can define your own filter functions, its quite easy as functions such as ~read-buffer~ and ~org-roam-node-read~ have ways to filter their results through predicate functions. In case you are not aware, ~org-roam-node-read~ is the function on which ~org-roam-node-find~ and ~org-roam-node-insert~ are based. Due to the way they are written, you can pass the predicate function directly to them, but they pass it to ~org-roam-node-read~.

   There are also some more niche filter functions I have defined, but they are defined inside another function for a specific purpose and not interactive. I will mention their predicate functions on that part of the explanation

** On the zetteldesk-scratch buffer
   Now this, is where all the fun begins. The zetteldesk-scratch buffer, is a temp buffer created by activating the global minor mode ~zetteldesk-mode~. If you remember on the introduction, I mentioned my basic source of inspiration for this, was the idea of spreading notes on my desk so I can view them, but digitally. This is where all of this is implemented. Firstly, I define the low-level function ~zetteldesk--create-scratch-buffer~ which essentially initialises the scratch buffer with the correct name and major-mode (org) and a hook that attaches this function to the zetteldesk-mode-on-hook. Then, there is ~zetteldesk-switch-to-buffer~ which opens the zetteldesk-scratch in a split with the current window. Optionally, if given a C-u argument, it will switch to it fullscreen. Usually, you want it in a split with something else, and that is why most of the functions defined below, use ~switch-to-buffer-other-window~ with this buffer. But this one has the option of fully switching to it. 

   The function that puts it all together is ~zetteldesk-insert-node-contents~. Now this one does quite a few things, so I will explain them one by one.
   First, choose a node that is part of the zetteldesk. Then in the current buffer insert a link to that node and after that, in the zetteldesk-scratch buffer, go to the very bottom of the buffer, insert a newline and then the contents of the file. Replace the string #+title: with a top level heading as in this buffer there will be multiple nodes, so you need a good way to navigate around (and I decided to use headings for that). If the node has only its ID in the :PROPERTIES: section, it removes that (as I think its not necessary to have in the new buffer). But unfortunately I "hardcoded" the number of characters to ignore (the number of characters it takes is 67 if anyone is interested) so if it has aliases or refs or sth, this will not fully work. But its better than having to manually remove the properties section or having it there imo. Finally, if given a universal argument (C-u), it also opens the zetteldesk-scratch buffer in a split.

   Now time for an explanation of how this is meant to work (imo at least). When doing revision, I thought it was a useful tool to create an outline file where you describe the entire lesson through links to notes you have written to put them in order. Then you can check them one by one, in the sensible order you sorted them to revise. But if you add the links with ~zetteldesk-insert-node-contents~ instead of ~org-roam-node-insert~ or even ~zetteldesk-node-insert~ if you were already viewing the filtered version, now all the text of your nodes will be in the zetteldesk-scratch buffer so you will not have to look at the nodes one by one.

   Alternatively, if someone wants to follow a different type of workflow where you don't insert links, but just wants to put the node contents on their scratch buffer I have defined the ~zetteldesk-insert-node-contents-without-link~ function for that purpose. Its the same function removing the part that adds the link. Plus, I made it default behaviour to open the zetteldesk-scratch buffer in a split in this situation as I felt it makes more sense.

   Then, as not all your material will be in the form of org-roam nodes, I defined a similar function for general org files ~zetteldesk-insert-org-file-contents~. This one, prompts you for an org buffer which is part of the zetteldesk and inserts its contents to the zetteldesk-scratch buffer. For this one though, there is no properties section that needs to be omitted. Something that needs to be dealt with though, is the fact that we want the title to be a top level heading and all other headings to be demoted by one level. I didn't worry about that in the org-roam-node function as those typically do not have headings. But these do have headings, so I think it makes sense to demote all headings by one and make the title be the only top level heading.

   But besides org files, there are other ways to distribute information such as pdf, rich text formats like MS Office, web browsers, info manuals etc.

   I have setup behaviour for pdfs and info manuals. For browsers, I think org-roam-protocol does the job. Captures the web page into an org file and then you input that file to your scratch buffer. For rich text formats, they generally don't interface well with emacs so I recommend converting them to pdf.

   For pdfs, I have the ~zetteldesk-insert-link-to-pdf~ function. This doesn't insert the contents of the pdf to the buffer as a lot of pdfs might be too long for that. But its got what I would say is a pretty neat behaviour. First, it prompts you for a pdf that is part of the zetteldesk and which page of the pdf do you want. I thought that as I will not be inserting anything I should at least be able to place a link to the pdf, in the page the user wants. I think it makes more sense and I like it for my own workflow as well. After taking that info, it goes to the bottom of the zetteldesk-scratch buffer, inserts a newline, and then a heading with title "Supportive Material - " description " (PDF)" where description is the file's name without the path to it and without the extension. This helps with indexing as you can search for headings with (PDF) in them if that is what you were looking for. Then, it inserts a link to the pdf, which points to the page you are interested in.

   If given the universal argument (C-u) and you had selected a region of text before calling the function, it will also insert the text you had selected before the link. This is useful if you were describing what the supplementary info is supposed to do before inserting it.

   For info nodes, I have made the function ~zetteldesk-insert-info-contents~. It prompts you for an info node you saved to the zetteldesk and inserts it to the scratch buffer in a way very similar to how the system handles pdfs. It inserts a heading with the name "Supportive Material - " info_node " (Info)" where info_node is the node's name as captured by ~Info-copy-current-node-name~. It also does not insert the first two lines of the Info buffer which have the contextual links of the node, as they don't really make sense when you are seeing the node in isolation in the zetteldesk-scratch buffer. However, I have also added a link inside the heading which takes you directly to the node inside the Info program so you can see the node in its context if you so desire.

   Lastly, I have a function which is mostly for my convenience as if you don't use the same conventions in your zettelkasten as me you will not find much use in this. The function ~zetteldesk-node-insert-if-poi-or-moc~ inserts links to all zetteldesk nodes that have one of the tags POI or MOC. MOC stands for Map Of Contents and is used mostly for index files. POI stands for Point Of Interest and is used for "large" files (large here meaning densely linked, therefore appearing large in the graph) to show that they are the most important parts of a subject. When revising a subject, its helpful to just drop a list of links to all MOCs and POIs of the subject. They are typically not a lot, so I could do it manually, but automating is fun.  

** A tour of the predicate functions
   This package is all about filtering your material to only see what you want to see. As mentioned above, this is done mostly through the use of filtered functions, functions that take another function as an argument and use it to filter down what they show. The function taken as an argument is called a predicate function (that is why all these functions are suffixed with a p, as done in core emacs functions as well like ~bufferp~ for example). As you can expect this package has a lot of filter functions. This sections is something like a walkthrough of all of these. 

   Obviously, the first and most important core predicate function of the package is ~zetteldesk-p~. It takes a buffer and checks if the value of the buffer-local variable ~zetteldesk~ in that buffer is different than its defualt value and returns the opposite boolean of that (as we want to keep only those where the value is different than the default). Then we have two other very core p-functions of the package ~zetteldesk-buffer-p~ and ~zetteldesk-node-p~. These are the functions used in the filtered versions of ~switch-to-buffer~ and ~org-roam-node-find~. ~zetteldesk-buffer-p~ is a simple ~and~ expression where BUFFER must be part of the zetteldesk, but not an org-roam-buffer (which is checked with the built-in ~org-roam-buffer-p~ function of org-roam). ~zetteldesk-node-p~ needs to translate the buffer that ~zetteldesk-p~ takes to a node, as it uses a node as its input argument. For this, I defined a new cl-defmethod inside org-roam called ~org-roam-node-buffer~ which finds the buffer a node is associated to. This is useful for a node in my opinion, but not one of the built-in access slots of an org-roam-node. Its biggest limitation is that it will return nil if the node isn't opened as there is no file buffer associated with the node's name. But in some cases, I actually take advantage of that. One such case is actually ~zetteldesk-node-p~ where if ~org-roam-node-buffer~ returns nil, the predicate function returns nil, as a node that hasn't been opened yet, can not be part of the zetteldesk. Furthermore, ~zetteldesk-add-node-to-desktop~, the function used for adding nodes to the zetteldesk, will open a buffer with the chosen node, behind the scenes so that ~zetteldesk-node-p~ can be used on it. Besides that, its essentially ~zetteldesk-p~ with BUFFER being replaced with (org-roam-node-buffer NODE).

   Besides these 3, which are the most important ones, I have defined 3 more for the system, which are used for more specific filters in a function.

   Firstly, there is ~zetteldesk-org-buffer-p~ which takes ~zetteldesk-buffer-p~ (~zetteldesk-buffer-p~ and not ~zetteldesk-p~ is required so that it does not display org-roam files) and issues an ~and~ expression to evaluate both that and if the major mode of said buffer is org. If yes, it returns t. This is used in ~zetteldesk-insert-org-file-contents~, which inserts the contents of an org-file in the zetteldesk-scratch buffer. Obviously, this requires the extra filter, cause if the completion menu allowed you to switch to a buffer that wasn't an org buffer and ran commands as if it was one, things will not go so well.

   Then, there is also ~zetteldesk-pdf-p~ which is an ~and~ expression of ~zetteldesk-p~ and checking if the major mode is ~pdf-view-mode~, which is used in ~zetteldesk-insert-link-to-pdf~ for similar reasons as above.

   Lastly, there is a more "general" org-roam predicate ~org-roam-node-poi-or-moc-p~ (I call it more general as its not about the contents of the zetteldesk) which checks if a node has the tag POI or the tag MOC, which is used in ~zetteldesk-node-insert-if-poi-or-moc~ a convenience function discussed in the above section.

   There is no predicate function for info nodes, because as discussed above they use a different mechanism due to not being persistent buffers.

* A Sample Workflow
  As I do not consider the documentation for this as good as I would want it to be, I thought it could be helpful if I put a sample of my own workflow and how I use this package here. This is how I use this package to do revision for my uni exams. As of Feb. 2022 writing this, this is the first time I try it, and its working out pretty well.

  I start off with selecting a topic to revise on. A lot of the files that have to do with it will be linked to the index, so I just add them to the zetteldesk with ~zetteldesk-add-backlinks-to-desktop~. Then I look at the list and notice any other large files whose backlinks I want added. Then if I remember that something else isn't here I will add it with ~zetteldesk-add-node-to-desktop~, but typically, everything will be linked either to the main index or to subindices/POIs of the subject. Then I look through the list with ~zetteldesk-remove-node-from-desktop~ to remove anything that is linked to one of these files in a very wide sense and not actually related to the subject. With that, I have everything I need in the zetteldesk and I am ready to start working. I go to the zetteldesk-scratch buffer and run ~zetteldesk-node-insert-if-poi-or-moc~ to enter all the POIs and MOCs of the subject to the buffer. These are typically the largest files of the zetteldesk. However, I also use ~zetteldesk-node-insert-sort-backlinks~ to check if any large files where missed from the above. With guidance from those and knowledge of how the chapters were "split up" during the lesson, I make a few headings with categories, ideally sorted in a sensible way. Then I try to fit every zetteldesk node in one of these categories (this is the reason I defined a seperate ~zetteldesk-node-insert~ filter function). With that, I have a very rough outline of the whole lesson.

  That is essentially part 1 of the workflow. After that, I create a new file in my zettelkasten which I typically call something along the lines of "Outline of lesson X". With the outline in one window and that file in the other, I write a description of everything included in the lesson and insert links to the appropriate nodes when they are mentioned. This should be one of the easier parts, as you are basically making a more verbose version of what you have on the scratch. Instead of having the list of links, you add some text between them to make a small write-up connecting them. But the thing that connects this all together, is that those links are not inserted using ~zetteldesk-node-insert~ but with ~zetteldesk-insert-node-contents~. Both of these do insert a link to the node. But ~zetteldesk-insert-node-contents~ has another side-effect. It inserts a copy of the file inside the zetteldesk-scratch buffer. Therefore, when I am done with writing the outline, I have a properly ordered list of every node I need to review. This is where the true revision comes in. To add all the nodes and write the outline, you need to remember some of the core concepts of the lesson and that acts as a small first revision. But the real revision comes afterwise when you go to your zetteldesk-scratch and read all the nodes you inserted one by one.
  This essentially acts as you reading everything you deemed even slightly important about the lesson, in an order you consider correct. Assuming you made good nodes the entire semester (which I currently strive a lot to do), this should be a very good and detailed revision on all the theory of the subject. Finally, to not lose this file on reboot (as the zetteldesk-scratch is a temporary file) I typically write the buffer to a file which I store in a folder about the lesson. Odds are I may not need it again, especially as all the info it has is inside of my zettelkasten. But I like saving it just in case. For anyone who isn't familiar with how you do that, that is done with the vanilla emacs command ~write-file~.

  Now, this workflow is probably not perfect for everyone. It works for me, it may not for you. But as all of this was written with a result in mind, I wanted to explain how I use these, so you can have a better understanding of the design choices. I would love to hear other ways to use this system, but that is the one I had in mind when creating this.
  
* Keybindings
  Keybindings in Emacs are a long discussion. I firmly believe that emacs is a tool which you can mold to your liking, and the fact that you can completely change all its keybindings with ease to those you like is a big part of that. I personally prefer evil style keybindings with Space as the global leader key. Someone else might like defaults, be inspired by defaults but change them a bit, or any other random thing.

  For this very reason, inside the package's source code, there is no keybinding definition. Its something that I believe you should decide by yourself. Ok, actually I am considering adding the keybindings and just not defining the prefix key, as besides the prefix key - which is strictly my personal preference - I believe the rest probably make sense for others as well, and even if they don't, by nature of emacs you can change them. Haven't decided fully yet, so for now I will keep everything unbound.

  However, if you just want some inspiration, I will leave the part of my config that sets up the zetteldesk keybindings below.

  #+BEGIN_SRC emacs-lisp

    (general-define-key
     :states 'normal
     :keymaps 'override
     :prefix "SPC z"
     "b" 'zetteldesk-switch-to-buffer
     "a" '(:ignore t :which-key "Add to Zetteldesk")
     "a b" 'zetteldesk-add-to-desktop
     "a n" 'zetteldesk-add-node-to-desktop
     "a i" 'zetteldesk-add-info-node-to-desktop
     "r" '(:ignore t :which-key "Remove from Zetteldesk")
     "r b" 'zetteldesk-remove-from-desktop
     "r n" 'zetteldesk-remove-node-from-desktop
     "r i" 'zetteldesk-remove-info-node-from-desktop
     "n" 'zetteldesk-node-find
     "s" 'zetteldesk-switch-to-scratch-buffer
     "i" '(:ignore t :which-key "Insert to Scratch Buffer")
     "i n" 'zetteldesk-insert-node-contents
     "i N" 'zetteldesk-insert-node-contents-without-link
     "i o" 'zetteldesk-insert-org-file-contents
     "i p" 'zetteldesk-insert-link-to-pdf
     "i i" 'zetteldesk-insert-info-contents)

    (general-define-key
     :states 'normal
     :keymaps 'org-mode-map
     :prefix ", z"
     "i" 'zetteldesk-node-insert
     "r" 'zetteldesk-remove-backlinks-from-desktop
     "b" 'zetteldesk-add-backlinks-to-desktop
     "p" 'zetteldesk-node-insert-if-poi-or-moc
     "s" 'zetteldesk-node-insert-sort-backlinks)

  #+END_SRC

  I use general to define all my keybindings, as I really like how easy it is to define stuff with it. As mentioned, my global leader key where most of my keybindings go is Space. z is the letter I have chosen for the zetteldesk keybindings (for obvious reasons) and luckily nothing else in my config really used it. Furthermore, some keybindings are meant to be ran in org-mode, so those are in an org-mode-map under , z. The comma is my org-mode specific leader key, so that is why these are in , z. 
