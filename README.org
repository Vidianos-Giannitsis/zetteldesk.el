#+TITLE: Zetteldesk.el a Revision and Outlining tool built on top of Org-Roam

* Table of Contents                                                     :TOC:
- [[#introduction][Introduction]]
- [[#installation][Installation]]
- [[#sample-config][Sample Config]]
- [[#getting-started][Getting Started]]
- [[#keybindings][Keybindings]]
- [[#debugging][Debugging]]
- [[#background-of-the-package][Background of the Package]]
- [[#related-work--thank-yous][Related Work & Thank yous]]

* Introduction
  Zetteldesk.el exposes a workflow where you select buffers and org-roam nodes from a completion menu and filter generic functions such as ~switch-to-buffer~ and ~org-roam-node-find~ to show only the ones you selected. Then it allows you to insert their contents in a seperate buffer and make an outline of the topic in question. Org-Roam is often regarded as your second brain, much larger in capacity than your regular brain. This package makes your second brain see only what your regular brain is thinking, and then allow you to view and organise all those thoughts in a simple manner. Essentially it tries to make a digital analog of spreading your notes in your desk to view them all at once. That is a big plus of handwritten notes, and as such a digital analog for this is helpful. I consider it an effective workflow originally meant for revising various topics for uni exams, but also useful for making things such as outlines or manuscripts.

  If this sounds interesting to you, a small tutorial of the package can be found [[https://github.com/Vidianos-Giannitsis/zetteldesk.el#getting-started][here]], detailed documentation of the package can be found in the [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/wiki][Wiki]] and the most interesting part of the Wiki (at least in my opinion) is the description of my workflow with the package in the [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/wiki/A-Sample-Workflow][Sample Workflow]] section
  
* Installation
  This package is currently not on MELPA. I would like to add it eventually however. To install this, simply clone this repository locally and add zetteldesk.el to your load-path.

  For instructions on how to do that, refer to https://www.emacswiki.org/emacs/LoadPath

  You can also install the package using straight.el with the following snippet

  #+BEGIN_SRC elisp

    (use-package zetteldesk
      :straight (zetteldesk
		 :type git :host github
		 :repo "Vidianos-Giannitsis/zetteldesk.el")

  #+END_SRC

* Sample Config
  For those of you who are not so much the reading types and just want a working config, which you can explore later I will leave a config that sets everything up here. I have tried to make the keybinding hydra as self explanatory as possible, and if you check function docstrings you should be able to understand what this does, but for a better idea, you should check [[https://github.com/Vidianos-Giannitsis/zetteldesk.el#getting-started][Getting Started]] and the [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/wiki][Wiki]].

  This assumes you have installed and setup [[https://github.com/org-roam/org-roam][org-roam]] (I would be surprised if you are checking this out without having setup org-roam though, as it relies on org-roam for a lot of things) and that you have installed [[https://github.com/abo-abo/hydra][Hydra]] and [[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][Pretty-Hydra]], as the package's default keybindings are made with a hydra using the ~pretty-hydra-define~ macro. They are all on Melpa so you shouldn't have trouble finding them.

  #+BEGIN_SRC elisp

    (require 'zetteldesk)
    (zetteldesk-mode 1)
    (setq zetteldesk-hydra-prefix (kbd "C-c z"))
    (require 'zetteldesk-kb)

  #+END_SRC

  After setting these, just press C-c z (or any other keybinding you want for the prefix) and explore the hydra.
  
* Getting Started
  
  First things first, once you have the package in your load-path, you need to require and activate the global minor-mode zetteldesk-mode. This mode does some background work to create a buffer named zetteldesk-scratch. This essentially acts as your desktop. This is where you put everything really.

  So a sample config would be
  #+BEGIN_SRC elisp
    (require 'zetteldesk)
    (zetteldesk-mode 1)
  #+END_SRC

  Then, I have prepared a few demos of the main features of the package, for you to look at to get an idea. For more detailed documentation, check the [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/wiki][Wiki]] of the package and the function docstrings. This is a short showcase of the main features.

  But first, here is a list of the main features of the package: 
  - Add/Remove Buffers or Org-Roam Nodes from the zetteldesk with various conveniences besides simple selection, such as selecting all backlinks of a node
  - Use the contents of the zetteldesk to view filtered versions of core functions such as ~org-roam-node-find~, ~org-roam-node-insert~ and ~switch-to-buffer~
  - Save specific parts of a manual inside the Info program to seamlessly jump between specific info nodes, even if unrelated
  - Insert the contents of an org-roam node in the zetteldesk-scratch buffer, leaving a link to the node in the current buffer. The selection is filtered to nodes in the zetteldesk
  - Insert the contents of an org-file or an Info-node to the zetteldesk-scratch as supplementary material to org-roam nodes. Again, the selection is filtered to org files (*but not* org-roam nodes) and Info-nodes in the zetteldesk respectively. 
  - Insert links to specific pages of a pdf, with a selection menu of only zetteldesk pdfs
  
  First, we can look at how you add or remove an org-roam node from the zetteldesk. This is shown in the gifs below

  Add/Remove

  You typically start with ~zetteldesk-add-backlinks-to-desktop~ which is for bulk adding of nodes, adding a node and all its backlinks as its very helpful to add everything related to a subject and them some things that were missed can be added with  ~zetteldesk-add-node-to-desktop~ or some things that in the end don't belong there can be removed with ~zetteldesk-remove-node-from-desktop~. For bulk removing ~zetteldesk-remove-backlinks-from-desktop~ is the main function you use. The other thing displayed here is the filtered version of ~org-roam-node-find~, ~zetteldesk-node-find~ which filters to show only files in the zetteldesk.
  
  With this, you can start working on your desktop. Unfortunately, I can't show you any real examples I have, as all my lesson nodes are in Greek which is illegible for most. So for demonstration purposes I will show you the process of dropping a note in your desktop, namely the zetteldesk-scratch buffer.

  Desktop

  The first function shown is ~zetteldesk-insert-node-contents-without-link~, which prompts for a node and inserts its contents to the zetteldesk-scratch. It specifies its without a link, as the one I primarily use ~zetteldesk-insert-node-contents~ also inserts an ID link to that node in the scratch buffer. My typical workflow (described shortly [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/wiki/A-Sample-Workflow][here]]) includes me writing an outline of the subject, linking every subject I mention. These links are inserted with this function so their contents are added to the scratch. There is also ~zetteldesk-switch-to-scratch-buffer~ to open the scratch buffer in a split with the current buffer. The version that doesn't insert a link (shown in the gif) does that by default, but the original ~zetteldesk-insert-node-contents~ doesn't do that by default, so this function is generally useful. 

  Another thing I want to showcase is how this package interfaces with the Info program, the built-in documentation viewer of Emacs. Info buffers are unique in the way that there aren't multiple. There is a single persistent buffer for Info. So besides the use of info buffers in the zetteldesk, for its own purposes, it needs to define a way to save the info buffers you want to be viewing. And also as this package defines a lot of filter functions, it needs a way to allow you to select a single info node and jump to it (which is done through a ~completing-read~). This is in my opinion useful even on its own. Check the gif below for a demonstation of the feature.

  info
  
  The function that does the adding is ~zetteldesk-add-info-node-to-desktop~ (and of course there is an equivalent ~zetteldesk-remove-info-node-from-desktop~), while the filter function is ~zetteldesk-info-goto-node~. Furthermore, I wouldn't consider this complete, if you couldn't insert a node you want to the zetteldesk-scratch besides switching to it in the info buffer. This is also possible with ~zetteldesk-insert-info-contents~, which is demonstrated here 
 
  info scratch
  
  Besides the contents, it also drops a link so you can read the node in its context (in the info buffer).
  
  And of course, as I already had all the backbone, it was very easy to add similar functionalities expanding to all emacs buffers. The functions ~zetteldesk-add-to-desktop~ and ~zetteldesk-remove-from-desktop~ are what you expect them to be. Choose a buffer and add it to the zetteldesk. The filter function for these is ~zetteldesk-switch-to-buffer~. Below is a demonstrative gif of how the filtered switch-to-buffer looks.

  buffers

  Last thing I consider super useful to showcase, is how the system handles references you want to insert to the zetteldesk besides the aforementioned org-roam files and info buffers.

  Things I would consider perfectly reasonable ways to distribute information are org-mode files outside org-roam, pdf, rich text formats like MS Office and web pages. Actually, rich-text formats don't interface well with emacs, so I recommend converting them to pdf, and I don't have something for web pages as org-roam-protocol already does the work for me. It captures an org-roam file and I just add the org-roam file. 

  Through ~zetteldesk-insert-org-file-contents~ you can insert all your org mode files to the zetteldesk-scratch. It follows a similar logic to ~zetteldesk-insert-node-contents~ with a major difference that it can handle headings, as most org files use them (the org-roam one doesn't as its more rare to see org-roam files with headings, as they are typically small files). For pdfs, you have the equivalent ~zetteldesk-insert-link-to-pdf~. This doesn't insert a pdf, as obviously that wouldn't be practical, but a link to it. The cool thing is that the link can point to a specific page in the pdf. But that's enough talking, I will let the gif do the rest

  org_pdf
  
  Note that the above functions filter to only show the appropriate files (org files that are not in org-roam or pdfs respectively) and that if they are in the zetteldesk.

  And that's the core of the package, which I wanted to showcase. For more detailed docs and part of the workflow I use with this explained, do check the package's wiki. 
  
* Keybindings
  Keybindings in Emacs are a long discussion. I firmly believe that emacs is a tool which you can mold to your liking, and the fact that you can completely change all its keybindings with ease to those you like is a big part of that. I personally prefer evil style keybindings with Space as the global leader key. Someone else might like defaults, be inspired by defaults but change them a bit, or any other random thing. However, it is true that default keybindings in packages significantly lower the entry point and help with learning the package easier. 

  For this reason, I have defined a set of hydras for the package's defaults, but I have not defined a prefix-key for the hydra, as that is something you will have to decide yourself imo. I like hydras for this kind of job as they allow large descriptions and are very convenient to use. They are defined with the [[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][pretty-hydra-define macro]] as I like how it looks. These keybindings are to an extent inspired by my personal keybindings, but due to their different nature (of trying to fit all of them in a single hydra) they are not identical. However I consider them very usable for the purposes of the package.

  But, as I consider it fully optional it's not in the main part of the package. Its in a seperate elisp file zetteldesk-kb.el, to load it use
  #+BEGIN_SRC elisp
    (require 'zetteldesk-kb)
  #+END_SRC

  The main hydra that contains all the keybindings is ~zetteldesk-main-hydra~, while I have defined 3 more supplementary hydras, ~zetteldesk-add-hydra~, ~zetteldesk-remove-hydra~ and ~zetteldesk-insert-hydra~ which are called from the main hydra. If you customize the value of the variable ~zetteldesk-hydra-prefix~ to a proper keybinding expression (using ~kbd~), the main hydra will automatically be bound to that key in every buffer with zetteldesk-mode active (meaning every buffer as its a global minor mode). Note though that due to the structure of the package, and my decision to not define a prefix key by default, you will need to set its value before loading the library as it will signal an error otherwise (due to the ~define-key~ expecting a keybinding and getting ~nil~). 

* Debugging
  This code is tested only on my machine, so there may be unexpected errors. If you find one, I would appreciate if you filed an issue about it. But before doing that, make sure you try reproducing it with emacs -Q. As a convenience, I use the following code to setup package.el, org-roam and finally zetteldesk.el in an emacs -Q buffer so I can test with a clean slate.

  #+BEGIN_SRC elisp

    ;; Setup package.el
    (require 'package)
    (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			     ("nongnu" . "https://elpa.nongnu.org/nongnu/")
			     ("elpa" . "https://elpa.gnu.org/packages/")))

    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))

    ;; Install and Setup Org-Roam
    ;; Set the org-roam directory to ~/org_roam as that is what I use, if
    ;; you need something different, change it before testing this
    (package-install 'org-roam)

    (add-hook 'after-init-hook 'org-roam-setup)
    (setq org-roam-v2-ack t)

    (use-package org-roam
      :config
      (setq org-roam-directory "~/org_roam"))

    ;; Load zetteldesk.el and turn on zetteldesk-mode to have a
    ;; functioning zetteldesk-scratch
    (load-file "~/Zetteldesk/zetteldesk.el")
    (zetteldesk-mode 1)

    ;; Then for testing the hydras from the zetteldesk-kb library
    (setq zetteldesk-hydra-prefix (kbd "C-c z"))
    (load-file "~/Zetteldesk/zetteldesk-kb.el")

  #+END_SRC
  
* Background of the Package
  So if you reached up to here, you are probably interested in this. So you can check out the background story of this package. This is how I concieved the package and everything leading up to the release. I find it interesting to read something like this as it gives a good description and use case for this, in an organic manner. Note that its rather lengthy and unfiltered though.
  
  So, while rereading the excellent book "How to Take Smart Notes" by Sonke Ahrens (around like 8-9 months after picking the workflow up) to have a more detailed look in some details I might have ignored starting out, I noticed that one interesting thing that was mentioned (would love to leave the very quote here but its been a few months and I am not in the mood of trying to find that exact sentence) was the idea of taking your zettels and spreading them on your desk to look at multiple of them at once. I started thinking about it and I wrote this idea in an org file. 
  
  #+begin_quote
    A desktop, is the top surface of a desk, or in the digital world an area in a computer screen in which some people arrange their icons, similarly to how they would arrange stuff in their desk. Now if I had an irl zettelkasten, I know for sure that my desktop would be filled with little notes with various topic when studying something. So why shouldn't I have a digital desktop where I can spread all my notes and look at them one by one, when studying. Wouldn't that be handy?
  #+end_quote

  Thus begun my planning of all this. I was originally gonna call this zettelkasten-desktop.el, but that one was quite large, so I just shortened it to zetteldesk.el.

  This started out really slowly with me thinking how I was gonna implement that idea and how it was all gonna pan out. I started with thinking of existing solutions for something similar. For example, I considered customising [[https://github.com/nex3/perspective-el][perspective.el]] to suit my needs as that had the ability of creating "perspectives" in which you can only view certain buffers. I quickly dropped that in favour of writing something from scratch. I felt that if I do it from scratch it would work out better as I would be more knowledgeable of what I am doing. Also, it was less work, because if I tried to customise a pre-existing package to suit my needs I would need to really go deep into learning what it does. I already had to do this for org-roam to write my addons to it, and as I am not a developer, have limited knowledge of elisp and also limited time to work on this, I thought it would be better if I wrote something from scratch using vanilla emacs and org-roam. Maybe I was wrong, but its fine, this has been working well so far for me.

  First thing I looked at was what kind of predicate I was gonna define and with what criteria I was going to filter things. I tried to follow a rather simple idea to do this and not overcomplicate things. Essentially, I define a buffer-local variable and give it a default value. Then I define the predicate function that shows when a buffer is part of the zettelkasten desktop. A buffer will be part of the desktop only if the value of that variable in the buffer is not equal to the default. I started planning out things by filtering buffers like this, but as I was going to use this with org-roam nodes as well, and for viewing nodes you are doing them a misservice if you do not use the commands defined from org-roam for traversing the database, I ported everything over to work with nodes as well learning a lot about the insides of org-roam in the process. There are probably a million other ways to make a simple user-friendly predicate, but changing the value of a buffer local variable seemed fairly easy to me so I went for it.
  
  When this was happening, I was in the second semester during which I took notes with org-roam and the zettelkasten method. I was proud to say that I had digitalised mostly everything I had notes for and had developed a good workflow for working with these notes (if anyone's interested on the workflow, some parts of it are described over on the part of my literate emacs config concerning Org-roam which you can find [[https://github.com/Vidianos-Giannitsis/Dotfiles/blob/master/emacs/.emacs.d/libs/zettelkasten.org][here]] and I might mention some things to explain some design choices and some functions I have defined). But after some time, the exam period was starting. Having worked on some of my intial ideas for this during the christmas holidays, I was done with the basic filter functions for switch-to-buffer and org-roam-node-find filtered down to only show the buffers/nodes I selected. I was really happy with them, but I didn't really know how to continue after that. Then, I realised two important things

1. My zettelkasten, having grown a lot more since the only other exam period I had used it in, was a bit harder to navigate so that I could do my revision in it.
2. The ideas I was considering with the zetteldesk, might be able to help with that.

  So I started thinking how I could combine these two. Having ran out of ideas for things to do, I thought trying to automate my revision process would be a fun puzzle. I had also not implemented the original idea, not having an idea of how I was gonna do it, but I said lets move on and I will think of something. I defined a new way of adding files to the zetteldesk besides a single buffer or a single node. That was to add a node and all its backlinks. As someone who works with big index files to sort their topics, this was very helpful, as I could add the majority of notes on a subject with a single command. Being able to have an org-roam-node-find function that shows only the nodes I am interested in, combined with org-roam UI, graphing that, was already a powerful tool. But there was basically no automation, nor had I achieved my original idea yet. All I had was a makeshift tool to filter my switch-to-buffer and org-roam-node-find to specific things. That was useful, but I wasn't really satisfied, I had to keep going. While doing revision for the first lesson, I noted down everything I did in a seperate file and was then thinking how I could automate it.

  Slowly, things started coming together. I crafted a workflow which significantly eased revision for university and also managed to implement, at least as best I could, my original vision. Then I experimented a bit more. If this came out good, which it was looking to be so, I could use it for more general purpose studying. Therefore, I needed to handle org-files that were outside the org-roam directory, material handed in pdf form, web content and I even setup a way to handle Info buffers (as I read a lot of documentation through those and I figured it might be a good idea). I have used this for every exam of my current semester as of writing this (February 2022) and it has worked wonders to help me revise everything. Obviously, this is only good revision if the notes themselves are good, but having spent quite a bit of time during the semester trying to understand the topics and make good notes about them, I didn't fear about that part. And the system's automation works to help the process of reviewing only the notes I want in a lot of way.

  And as in the buffer that puts all of this together, I sort things with headings, I thought that maybe this could also be used as an outliner tool. I will look at how people do those and implement some stuff specifically for that, but for now, its not here. I think it might be usable for that purpose though anyways.

  This is where we currently are. The main other thing I want to do for this, is to play around a bit with [[https://github.com/nobiot/org-remark][org-remark]]. I believe that in such tool, the ability to highlight things and add margin notes to it might be really useful. In general I do not really use this right now, so it will take some time to do that, but I look forward to it. I also add small things to it in a rather regular basis, whenever I feel something is missing. The development of this, is very closely connected with my studying, so if I find something I can improve I will try to do so.

  And after this incredibly long, and possibly unnecessarily detailed introduction lets dive into what this package does.

* Related Work & Thank yous
  In any kind of work you do, its a good practice to cite your sources of inspiration, and how your work differentiates itself from others. Furthermore, its also a good practice to say thanks to the people that helped, either directly or inderictly to make this what it is. So here's mine

  Of course this list couldn't start with anything other than the exceptional book [[https://takesmartnotes.com/][How to Take Smart Notes]] by Sonke Ahrens. This book is one of the best books I have read. It is an excellent introduction to the idea of the Zettelkasten and quotes from that book was what sparked the original thoughts. Its definitely my #1 source of inspiration. In that book, a [[http://zettelkasten.danielluedecke.de/en/][slip-box program]] is recommended. Trusting the author, I decided to check it out, even though I was certain I was gonna use emacs for my zettelkasten. This program is honestly pretty decent and some stuff in zetteldesk.el was inspired by it. Especially its Outliner is a pretty good looking software. Another thing that gave me inspiration is the book [[https://www.goodreads.com/book/show/16174518-how-to-make-a-complete-map-of-every-thought-you-think][How to Make a Complete Map of Every Thought you Think]], which had some pivotal ideas for my workflow.

  For the people that helped me, I didn't have any direct help. I had an idea and I just made it happen. But I wouldn't be able to get the knowledge to get here without a few people. The two main thank yous I would have to give are David Wilson from [[https://www.youtube.com/c/SystemCrafters][System Crafters on Youtube]] and the FSF for publishing the excellent book "An Introduction to Emacs Lisp" which helped me learn the language. Lastly, I would also like to thank [[https://www.reddit.com/r/emacs/][r/emacs]] on reddit. Reddit is infamous for not having a very good community. A lot of people disregard it as a rather bad social media with little use. But r/emacs, is truly a great community. Whenever I can't find an answer to a problem myself, I am certain that if I go to r/emacs and ask, someone will be able to help me, as people have in the past. Not to mention that I have gotten a lot of suggestions for this package from r/emacs, and to an extent its community helped me make this into what it is. So to everyone there, thanks for making this community what it is, its great!

  Finally, for some similar projects and how this one differentiates itself. This is definitely a non-exhaustive list as I don't know much of emacs. But for what I know, here is some similar work.

  - [[https://github.com/localauthor/zk][zk]] is a zettelkasten implementation for emacs that relies on a lot of low-level functions for its functionality. It has a feature called zk-desktop which is conceptually rather similar to what I have done. However, this is a solution of its own, completely independent of org-roam, while I wanted a solution to handle my org-roam repository
  - [[https://github.com/publicimageltd/delve][Delve]] is conceptually a rather similar package to this. Its built on top of org-roam and its got the idea of gathering nodes in a seperate buffer where you can play around with each seperately, a concept rather similar to that of zetteldesk. The main difference between the two is how their system is implemented. Zetteldesk is a package made in mind with filter functions to view only parts of your zettelkasten, but view them with the same UI Org-Roam uses, while Delve seems to have its own way of doing things, with not so many similarities to the UIs Org-Roam exposes. Both have their advantages and disadvantages, so use whichever one you like. The only other major difference I could notice is that zetteldesk has behaviours for handling supplementary materials such as pdfs and info nodes, while Delve seems to handle only nodes.
  - [[https://github.com/alphapapa/bufler.el][Bufler]] is a package made for playing around more with your buffers more. Zetteldesk also has similar functionality, but its not its core focus, so obviously I would consider it inferior in this regard. I just added the buffer stuff as it made sense conceptually to me to do more than org-roam nodes.
  
* COMMENT Things to do
  An important plan of mine is to set up better org-remark integration with this package as its something really interesting I haven't gone around to doing. 

  Another thing I am thinking of is looking more into outliner software and if there is something I want to implement from those.

  Saving the current state of the Zetteldesk. Although I have no clue how. Maybe if I am able to save the value of a buffer local variable between sessions its possible. 

  Create a variable that controls whether insertions happen in the current buffer or the zetteldesk-scratch buffer as its been recommended to me.

  Consider making a video showing all the features to avoid having to use large sized gifs in the README

