#+TITLE: Zetteldesk.el Literate Config

This file was originally part of my emacs config in the org-roam section. However, the more mature this package grew, I decided I should split it into its own org document so I can port it over to the zetteldesk.el github so it auto-tangles easier. In a way you can view this as some sort of documentation, but its just my thoughts when I write them. The proper documentation is really the wiki.

* Table of Contents                                                     :TOC:
- [[#implementing-the-zettelkasten-desktop-to-org-roam][Implementing the Zettelkasten "desktop" to org-roam]]
  - [[#description][Description]]
  - [[#dependencies][Dependencies]]
  - [[#predicate-functions][Predicate Functions]]
  - [[#adding-and-removing-things-in-the-zetteldesk][Adding and Removing things in the Zetteldesk]]
  - [[#filter-functions][Filter functions]]
  - [[#on-the-zetteldesk-scratch-buffer][On the zetteldesk-scratch buffer]]
  - [[#save-the-state-of-the-zetteldesk][Save the state of the zetteldesk]]
- [[#keybindings][Keybindings]]
- [[#org-remark-integration][Org-remark integration]]
  - [[#preamble][Preamble]]
  - [[#code][Code]]
- [[#handling-notes-on-articles-better---literature-notes][Handling notes on articles better - Literature Notes]]
  - [[#preamble-1][Preamble]]
  - [[#reference-notes-from-bibtex-entries][Reference notes from Bibtex Entries]]
  - [[#using-citar-as-a-backend-for-zetteldesk-ref][Using Citar as a backend for zetteldesk-ref]]
- [[#info-nodes][Info Nodes]]
  - [[#preamble-2][Preamble]]
  - [[#the-rest-of-the-code][The rest of the code]]
- [[#providing-the-packages-to-be-loaded-in-initel][Providing the packages to be loaded in init.el]]

* Implementing the Zettelkasten "desktop" to org-roam 
  A desktop, is the top surface of a desk, or in the digital world an area in a computer screen in which some people arrange their icons, similarly to how they would arrange stuff in their desk. Now if I had an irl zettelkasten, I know for sure that my desktop would be filled with little notes with various topic when studying something. So why shouldn't I have a digital desktop where I can spread all my notes and look at them one by one, when studying. Wouldn't that be handy?

  This very thought is what started this idea. The idea of the zettelkasten-desktop, which I shortened to zetteldesk as I wanted my functions to not have huge names. The plan for the finished project is a dedicated buffer in which I can input whichever note I want and view them all at the same time, a way to create a true desktop experience inside emacs.
  
** Description
   I have published this as a package on github so a description is needed in the top of the file. This section is basically that part.

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;;; zetteldesk.el --- A revision and outlining tool for org-roam  -*- lexical-binding: t; -*-

     ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
     ;; Maintainer: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
     ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk.el
     ;; Package-Requires: ((emacs "27.1") (org-roam "2.0"))
     ;; Tested on Emacs 27.2 and org-roam v2.2
     ;; Created: 6th February 2022
     ;; License: GPL-3.0
     ;; Version: 1.0.1

     ;; This file is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; For a full copy of the GNU General Public License
     ;; see <https://www.gnu.org/licenses/>.

     ;;; Commentary:

     ;; This package provides various filter functions to "traverse" your
     ;; org-roam database more smoothly.  I use it for doing revision in
     ;; lessons and I personally find it highly efficient for this
     ;; purpose.  Its also good to just sort out your thoughts.  In general,
     ;; org-roam lacks a good framework for filtering your nodes although
     ;; it has all the backend for doing that.

     ;;; Code:
   #+END_SRC
   
** Dependencies
   As I want this to work independently to my config, this section has a copy of all the custom function I use which were not defined in this section as I felt they fit more somewhere else in my config. These are the dependencies this has from my config. For general dependencies I will do those once this is actually complete enough to make its own package

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;; -- DEPENDENCIES --
     ;; These are some functions that are needed for the package to work as
     ;; it should, but that are not specific to the package

     (require 'org-roam)

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X.
     NODE is an org-roam-node"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
	 "Access slot \"backlinks\" of org-roam-node struct CL-X.

     This is identical to `org-roam-node-backlinkscount' with the
	 difference that it returns a number instead of a fromatted
	 string. This is to be used in
	 `zetteldesk-roam-node-sort-by-backlinks'. NODE is an org-roam-node."
	 (let* ((count (caar (org-roam-db-query
			      [:select (funcall count source)
				       :from links
				       :where (= dest $s1)
				       :and (= type "id")]
			      (org-roam-node-id node)))))
	   count))

     (defun zetteldesk-roam-node-poi-or-moc-p (NODE)
       "Check if NODE has the tag POI or the tag MOC.  Return t if it does."
       (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	   (string-equal (car (org-roam-node-tags NODE)) "MOC")))

     (defun zetteldesk-roam-backlink-query ()
       "Simple org-roam query function.
     Stores the IDs of all the files that link to the node at point.
     This is a modified part of the `org-roam-backlinks-get' function
     keeping only the part necessary for `org-roam-backlink-files' to
     work as this is a complimentary function to that"
       (org-roam-db-query
	[:select [source dest]
		 :from links
		 :where (= dest $s1)
		 :and (= type "id")]
	(org-roam-node-id (org-roam-node-at-point))))

     (defun zetteldesk-roam-backlink-query* (NODE)
       "Run `zetteldesk-roam-backlink-query' with NODE.

     Instead of returning a list of the backlinks of
     `org-roam-node-at-point', find the backlinks of NODE.  This is
     handy in cases where NODE is read through `org-roam-node-read'
     and doesn't have to be the `current-buffer'"
       (org-roam-db-query
	     [:select [source dest]
		      :from links
		      :where (= dest $s1)
		      :and (= type "id")]
	     (org-roam-node-id NODE)))

     (defun zetteldesk-roam-node-sort-by-backlinks (completion-a completion-b)
       "Sorting function for org-roam that sort the list of nodes.
     Sorting is done accordint to the number of backlinks.  This is
     the sorting function in `org-roam-node-find-by-backlinks' and
     `zetteldesk-node-insert-sort-backlinks'.  Arguments COMPLETION-A
     and COMPLETION-B are same as in
     `org-roam-node-read-sort-by-file-atime'"
       (let ((node-a (cdr completion-a))
	     (node-b (cdr completion-b)))
	 (>= (org-roam-node-backlinkscount-number node-a)
	     (org-roam-node-backlinkscount-number node-b))))

   #+END_SRC
   
** Predicate Functions
I tried to follow a rather simple idea to do this and not overcomplicate things. Essentially, I define a buffer-local variable and give it a default value. Then I define the predicate function that shows when a buffer is part of the zettelkasten desktop. A buffer will be part of the desktop only if the value of that variable in the buffer is not equal to the default. I define the low level predicate functions that check if a buffer or node is part of the zetteldesk and then I define a predicate that checks if a buffer is part of the zetteldesk but not an org-roam file, as on the switch-to-buffer prompt I do not care about org-roam files (I can view them with org-roam-node-file) and another predicate which filters the list down further to only include org files that are part of the zetteldesk but not org-roam files (which is handy for another function below).

#+BEGIN_SRC elisp :tangle zetteldesk.el

  ;; -- PREDICATE FUNCTIONS --
  ;; This section contains the predicate functions the package uses. The
  ;; core of the package is that it provides well filtered completion
  ;; menus as chosen by the user, so obviously predicate functions are
  ;; core to the package

  (defcustom zetteldesk-desktop
    "default"
    "Buffer local variable.
  Checks if the current buffer is part of the zetteldesk.  A buffer
  is part of the zetteldesk only if the value of this variable is
  not its default value in that buffer."
    :type 'string
    :group 'zetteldesk
    :local t)

  (defconst zetteldesk-desktop-default
    "default"
    "Default value of `zetteldesk-desktop'.

  This stores the default value through a `defconst' so it can't be
  modified to do a comparison between it and the current value of
  `zetteldesk-desktop'.")

  (defun zetteldesk-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk-desktop'."
    (not (equal zetteldesk-desktop-default
		(buffer-local-value 'zetteldesk-desktop (cdr BUFFER)))))

  (defun zetteldesk-buffer-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk-desktop'.
  Then check if BUFFER is not associated to an org-roam file.

  Org-roam file buffers are better viewed with `org-roam-node-file'
  so this function filters down the database to non org-roam
  zetteldesk buffers.  This is what is used to create the filter
  function `zetteldesk-switch-to-buffer'"
    (and (zetteldesk-p BUFFER) (not (org-roam-buffer-p (cdr BUFFER)))))

  (defun zetteldesk-node-p (NODE)
    "Check if NODE is associated with an open buffer.
  If it is, check if that buffer is part of the current
  `zetteldesk-desktop'.  If it isn't, return nil.

  This function is used as a filter function to create
  `zetteldesk-node-find' which is a filtered view of
  `org-roam-node-find'"
    (if (org-roam-node-buffer NODE)
	(not (equal zetteldesk-desktop-default
		    (buffer-local-value 'zetteldesk-desktop (org-roam-node-buffer NODE))))
      nil))

  (defmacro zetteldesk-mode-buffer-p (BUFFER MODE)
    "Check if BUFFER is part of the `zetteldesk-desktop' and in `major-mode' MODE.

  This macro is meant to be used to write filter functions to be
  passed to `read-buffer' variants such as
  `zetteldesk-org-buffer-p' which is used in
  `zetteldesk-insert-org-file-contents'.  BUFFER is in the form
  required for `read-buffer' while MODE should be a symbol such as
  'org-mode."
    `(and (zetteldesk-buffer-p ,BUFFER)
	  (equal (buffer-local-value 'major-mode (cdr ,BUFFER)) ,MODE)))

  (defun zetteldesk-org-buffer-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk-desktop'.
  Then check if the file is an org file but not one that belongs to
  org-roam.

  This is used as the filter function for
  `zetteldesk-insert-org-file-contents' which prompts for an org
  file, but as `zetteldesk-insert-node-contents' is a superior
  version for org-roam nodes, that function should not prompts for
  those files"
    (zetteldesk-mode-buffer-p BUFFER 'org-mode))

  (defun zetteldesk-pdf-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk-desktop' and also a pdf file."
    (zetteldesk-mode-buffer-p BUFFER 'pdf-view-mode))

#+END_SRC

#+RESULTS:
: zetteldesk-pdf-p

** Adding and Removing things in the Zetteldesk
   I define a few adding mechanisms and the matching removing ones, as can seen below. The first is adding/removing a buffer, the second is for a node and then I have two ways of playing with a nodes backlinks. I can add a node and all its backlinks to the zetteldesk, or I can select a node and add one of its backlinks to the zetteldesk. Both have their use cases imo. For the last one, I believe there is no need for a matching removing one. 

   
  #+BEGIN_SRC elisp :tangle zetteldesk.el

    ;; -- ADD/REMOVE THINGS IN THE ZETTELDESK --
    ;; To get a system where the user can get multiple filtered views of
    ;; the nodes/buffers of their choice, obviously you need functions
    ;; that allow the user to add them to something. And then, you also
    ;; need ways to remove things, because people make mistakes.

    (defmacro zetteldesk--add-buffer (BUFFER)
      "Add BUFFER to the current `zetteldesk-desktop'.

    This is a low-level macro used in all zetteldesk-add
    functions.  Given BUFFER it creates the code required to add the
    buffer to the zetteldesk.  For example all
    `zetteldesk-add-to-desktop' is, is an interactive call to this
    macro.  Other functions need more stuff, but deep-down they all
    use this macro."
      `(with-current-buffer ,BUFFER
	 (setq-local zetteldesk-desktop "foo")))

    (defun zetteldesk-add-to-desktop (BUFFER)
      "Add BUFFER to the current `zetteldesk-desktop'."
      (interactive "b")
      (zetteldesk--add-buffer BUFFER))

    (defun zetteldesk-add-node-to-desktop (NODE)
      "Add NODE to the `zetteldesk-desktop'.
    If there isn't a buffer associated to it, create it.  NODE is an
    org-roam node read through `org-roam-node-read'"
      (interactive (list (org-roam-node-read)))
      (let ((buffer (org-roam-node-buffer NODE))
	     (file (org-roam-node-file NODE))
	     (org-startup-with-latex-preview nil))
	(if buffer
	    (zetteldesk--add-buffer buffer)
	  (zetteldesk--add-buffer (find-file-noselect file)))))

    (defun zetteldesk-add-poi-or-moc-backlink-to-desktop ()
      "Prompt the user to select an org-roam node that has a specific tag.
    Looks for the POI or MOC tag (filtering done with
    `zetteldesk-roam-node-poi-or-moc-p') and collects its ID and backlinks.
    Then, prompt the user to select one of its backlinks and add that
    to the zetteldesk."
      (interactive)
      (let* ((source (org-roam-node-read nil #'zetteldesk-roam-node-poi-or-moc-p))
	     (source-id (org-roam-node-id source))
	     (backlinks (zetteldesk-roam-backlink-query* source)))
	(zetteldesk-add-node-to-desktop
	 (org-roam-node-read nil (lambda (NODE)
				   (let* ((id (org-roam-node-id NODE))
					  (id-list (list id source-id)))
				     (member id-list backlinks)))))))

    (defun zetteldesk-add-backlinks-to-desktop ()
      "Add the current buffer and all its backlinks to the `zetteldesk-desktop'.

    This function queries the database for all the nodes that link to
    the current node with the `zetteldesk-roam-backlink-query' function and
    then recursively checks if there is an open buffer associated
    with them, and if so adds it to the `zetteldesk-desktop'"
      (interactive)
      (setq-local zetteldesk-desktop "foo")
      (let ((backlinks (length (zetteldesk-roam-backlink-query)))
	    (org-startup-with-latex-preview nil))
	(dotimes (number backlinks)
	  (let* ((id (car (nth number (zetteldesk-roam-backlink-query))))
		  (node (org-roam-node-from-id id))
		  (buffer (org-roam-node-buffer node))
		  (file (org-roam-node-file node)))
	    (if buffer
		(zetteldesk--add-buffer buffer)
	      (zetteldesk--add-buffer (find-file-noselect file)))))))

    (defmacro zetteldesk--remove-buffer (BUFFER)
      "Remove BUFFER from the current `zetteldesk-desktop'.

    This is a low-level macro used in all zetteldesk-remove
    functions.  This function is identical in logic to
    `zetteldesk--add-buffer', however it is for removing thingss
    instead of adding."
      `(with-current-buffer ,BUFFER
	 (kill-local-variable 'zetteldesk-desktop)))

    (defun zetteldesk-remove-from-desktop (BUFFER)
      "Remove BUFFER from the current `zetteldesk-desktop'."
      (interactive "b")
      (zetteldesk--remove-buffer BUFFER))

    (defun zetteldesk-remove-node-from-desktop (NODE)
      "Remove NODE from the `zetteldesk-desktop'.
    NODE is an org-roam node
    and is read through `org-roam-node-read'"
      (interactive (list (org-roam-node-read nil #'zetteldesk-node-p)))
      (let ((buffer (org-roam-node-buffer NODE)))
	(zetteldesk--remove-buffer buffer)))

    (defun zetteldesk-remove-backlinks-from-desktop ()
      "Remove from the `zetteldesk-desktop', the current buffer and its backlinks.

    This function is essentially a carbon copy of
    `zetteldesk-add-backlinks-to-desktop' but instead of adding the
    buffer to the desktop it removes it."
      (interactive)
      (kill-local-variable 'zetteldesk-desktop)
      (let ((backlinks (length (zetteldesk-roam-backlink-query))))
	(dotimes (number backlinks)
	  (let* ((id (car (nth number (zetteldesk-roam-backlink-query))))
		  (node (org-roam-node-from-id id))
		  (buffer (org-roam-node-buffer node)))
	    (when buffer
	      (zetteldesk--remove-buffer buffer))))))


  #+END_SRC 

  #+RESULTS:
  : zetteldesk-remove-backlinks-from-desktop
   
** Filter functions
   Here I define the functions which give you a filtered view of switch-to-buffer and org-roam-node-find to the current zetteldesk. I also define a filtered view of org-roam-node-insert as its not rare to want to insert a link to a file from the zetteldesk and an iteration of that, that also sorts by backlinks.

   Lastly, trying to handle info buffers, I add a filtered view of Info-goto-node, using completing-read.

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;; -- FILTER FUNCTIONS --
     ;; This section is about defining all the functions that show you the
     ;; filtered results of all your nodes/buffers

     (defun zetteldesk-switch-to-buffer ()
       "Execute a filtered `switch-to-buffer'.
     The filter is done using `zetteldesk-buffer-p' to show only
     buffers that are part of the current `zetteldesk-desktop' and not
     `org-roam-node's."
       (interactive)
       (switch-to-buffer (read-buffer "Zetteldesk Buffers: " nil nil #'zetteldesk-buffer-p)))

     (defun zetteldesk-node-find ()
       "Execute a filtered `org-roam-node-find'.
     The filter is done using `zetteldesk-node-p' to show only nodes that are
     part of the current `zetteldesk-desktop'"
       (interactive)
       (org-roam-node-find nil nil #'zetteldesk-node-p))

     (defun zetteldesk-node-insert ()
       "Execute a filtered `org-roam-node-insert'.
     The filter is done using `zetteldesk-node-p' to show only nodes that are
     part of the current `zetteldesk-desktop'"
       (interactive)
       (org-roam-node-insert #'zetteldesk-node-p))

     (defun zetteldesk-node-insert-sort-backlinks ()
       "Select a node that is part of the zetteldesk.
     The function used is `org-roam-node-read' in a UI sorted by the
       number of backlinks.  Insert a link in the current buffer to
       the selected node.

     This function essentially has the core functionality of
     `org-roam-node-insert', but it uses `org-roam-node-read' instead
     as only that can take a sort-function.  Some files may be
     important to their topic, but not MOCs or POIs, so this function
     acts essentially as a complimentary function to
     `zetteldesk-node-insert-if-poi-or-moc' to check if that one
     missed something you want to include."
       (interactive)
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p #'zetteldesk-roam-node-sort-by-backlinks))
	      (id (org-roam-node-id node))
	      (description (org-roam-node-formatted node)))
	 (insert (org-link-make-string
		  (concat "id:" id)
		  description))))


   #+END_SRC
    
** On the zetteldesk-scratch buffer
   The zetteldesk-scratch buffer is a bit equivalent to the emacs scratch buffer. Its essentially a buffer unique to the session in which you can drop all the links, node contents or whatever else interests you and use it as the place to hold your crude notes until you drop them where they belong. I also envision this to be the buffer in which you drop all the notes you want to view at one time, in the way you would spread them on your desk.

   I am considering making a global minor mode zetteldesk-mode in which map you can put all your keybindings if you do not want the override map littered with those. It will also have a hook when turned on to create the scratch buffer. I will do this as I find it more classy to enable a minor mode than to just run the zetteldesk-create-scratch-buffer at initialization

   Things I have implemented so far
   - Creating a global minor mode for the zetteldesk.
   - Creating a function which initialises the zetteldesk-scratch buffer and hook that to the on-hook of zetteldesk-mode. The primary reason for wanting to define the minor mode was to enable it on startup and have this hook initialise the scratch buffer so I do not have to worry about it. The other reason is that for distributing this as a package I think it makes sense for it to have a minor mode in which I could possibly isolate the keybindings.
   - A function that inserts links to all the POIs in the zetteldesk to the current buffer. The way I have my zettelkasten sorted, my index files have the MOC (map of contents) tag and other important files of a subject have the POI (point of interest) tag. POIs are chosen by opening org-roam UI, blacklisting index files (in my case blacklisting the MOC tag), having a high value for "Node connections size scale" and seeing which nodes stand out the most. This is an idea taken from the book How to make a complete map of every thought you think. I use my zettelkasten for university notes and when revisioning its a great tool to be able to insert links to all POIs in some sort of scratch buffer, then sorting them and with that writing an outline of everything in that lesson. In a way, this does function as an outliner tool.
   - A function that prompts for a node inside the zetteldesk and inserts its contents to the zetteldesk-scratch buffer omitting the properties section where the id is stored. As it uses an absolute number for this, it doesn't exactly omit properties if the node has aliases or refs, I could consider trying to fix that, but I do not know how as of now. It also replaces the title keyword with a top level heading. This way you can add any node to your scratch buffer. This is equivalent to taking the note out of the drawer and putting it into your desk, the very first part of what I plan for this tool.
   - A similar function which prompts for org files in the zetteldesk but excluding org-roam files. Its behaviour is a bit different. No links are inserted as they are not needed, no part of the file is truncated as typically the first line is the title, the title is again changed to a top level heading, but as most big org files have some kind of structure to them, I also demote all their headings by 1, as their top level heading will be the title. This is part of an idea I had that this system should integrate with more than org-roam files (albeit that being the main plan) because your notes could also be in other org files.
   - A function that prompts the user to select a pdf that is part of the zetteldesk and a page in that pdf and inserts a link to that pdf, in that page. The link sits under a heading which has a specifically formatted name of the type "Supplementary Material - name_of_pdf (PDF)". Also has functionality of inserting the highlighted region of text to the zetteldesk-scratch buffer.

   Only other supportive material for any kind of work/research I could think of is source code files and browser pages. For source code files, it is in my opinion trivial to paste the code into an org mode source code block. I might automate it a bit better in the future, but for now I am not that interested in setting up something like this. For web pages, there really wouldn't be a point in inserting the web page verbatim, but only a link and some notes about it. This is already handled by org-roam protocol and that capture template of mine so if anything I will mention it and prompt to that capture template for what I think it should have. There is also screenshots and MS Office formats I guess but screenshots can be pasted into an org file from the clipboard and therefore require no automation and all MS Office formats aren't that readable in Emacs in the first place so they should be converted to pdf and handled by that imo. 

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;; -- *ZETTELDESK-SCRATCH* --
     ;; This is the section where it all comes together. The
     ;; zetteldesk-scratch buffer is a special buffer defined here on which
     ;; you drop all your stuff. Its what molds the whole workflow together

     (defcustom zetteldesk-kb-map (make-sparse-keymap)
       "This variable is the keymap for `zetteldesk-mode'."
       :type 'keymap
       :group 'zetteldesk)

     (defcustom zetteldesk-insert-scratch-or-current-buffer t
       "Customization variable.
     Decides whethere zetteldesk-insert functions will insert to the
     ,*zetteldesk-scratch* buffer or the current buffer.  Default value
     is t which makes those functions insert to the scratch.  Setting
     it to nil will make those functions insert to the current buffer,
     for whichever usecase you might want"
       :type 'string
       :group 'zetteldesk)

     (defun zetteldesk--create-scratch-buffer ()
       "Create the zetteldesk-scratch buffer and put it in `org-mode'."
       (let ((buffer (generate-new-buffer "*zetteldesk-scratch*"))
	     (org-startup-with-latex-preview nil))
	 (with-current-buffer buffer
	   (org-mode))))

     ;;;###autoload
     (define-minor-mode zetteldesk-mode
       "Toggles the global `zetteldesk-mode'.

     When turned on, this mode initialises the *zetteldesk-scratch*
     buffer, a useful part of the whole zetteldesk workflow."
       :init-value nil
       :global t
       :group 'zetteldesk
       :keymap zetteldesk-kb-map
       :lighter " zetteldesk"
       (when zetteldesk-mode
	 (zetteldesk--create-scratch-buffer)))

     (defmacro zetteldesk-insert-location ()
       "Find the location the zetteldesk-insert functions should insert to.

     The decision is made depending on the variable
     `zetteldesk-insert-scratch-or-current-buffer'.  Check its
     docstring for more info.  This is used in all zetteldesk-insert
     functions to decide if the insertion should happen in
     ,*zetteldesk-scratch or the current buffer."
       `(if zetteldesk-insert-scratch-or-current-buffer
		       "*zetteldesk-scratch*"
		     (current-buffer)))

     (defmacro zetteldesk-insert-switch-to-scratch (arg)
       "Switch to the *zetteldesk-scratch* if ARG is the `\\[universal-argument]'.

     All the zetteldesk-insert functions have a similar logic of
     switching to the *zetteldesk-scratch* buffer in a split if given
     a `\\[universal-argument]'.  To avoid repetition, this macro
     expands to the needed code."
       `(when (equal ,arg '(4))
	  (switch-to-buffer-other-window "*zetteldesk-scratch*")))

     (defmacro zetteldesk--replace-title ()
       "Replace \"#+title: \" with \"* \".

     A lot of the zetteldesk-insert functions need this functionality
     so I implemented it as a simple macro."
       `(while (search-forward "#+title: " nil t)
	  (replace-match "* " nil t)))

     (defun zetteldesk-switch-to-scratch-buffer (&optional arg)
       "Open the zetteldesk-scratch buffer in a split with the current buffer.

     Optionally, if given optional argument ARG, which needs to be the
     `\\[universal-argument]' switch to the *zetteldesk-scratch*
     buffer without issuing a split."
       (interactive "P")
       (if (equal arg '(4))
	   (switch-to-buffer "*zetteldesk-scratch*")
	 (switch-to-buffer-other-window "*zetteldesk-scratch*")))

     (defun zetteldesk-node-insert-if-poi-or-moc ()
       "Filter `org-roam-node-list' to show zetteldesk-nodes only.
     Then filter that to only those that have the POI or MOC tag with
     `zetteldesk-node-p' and `zetteldesk-roam-node-poi-or-moc-p'.  Then
     insert a link to every one of those nodes and seperate them with
     commas"
       (interactive)
       (let* ((init_list (org-roam-node-list))
	      (zetteldesk_nodes (cl-remove-if-not #'zetteldesk-node-p init_list))
	      (nodes_poi (cl-remove-if-not #'zetteldesk-roam-node-poi-or-moc-p zetteldesk_nodes)))
	 (while nodes_poi
	   (let* ((node (car nodes_poi))
		  (description (org-roam-node-formatted node)))
	     (insert (org-link-make-string
		      (concat "id:" (org-roam-node-id node))
		      description))
	     (insert ", "))
	   (setq nodes_poi (cdr nodes_poi)))))

     (defun zetteldesk-insert-node-contents (&optional arg)
       "Select a node that is part of the current `zetteldesk-desktop'.
     Add a link to it at point and then insert its contents to the
     bottom of the *zetteldesk-scratch* buffer after inserting a
     newline there.  Remove the first 67 characters which is the
     properties section if it only contains the ID of the node as its
     unneeded and change the string #+title to a top level heading as
     its more practical when inserting the contents of multiple files.

     If given the optional argument ARG, which needs to be the
     `\\[universal-argument]' also switch to the *zetteldesk-scratch*
     buffer in a split."
       (interactive "P")
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	      (file (org-roam-node-file node))
	      (description (org-roam-node-formatted node))
	      (location (zetteldesk-insert-location)))
	 (insert (org-link-make-string
		  (concat "id:" (org-roam-node-id node))
		  description))
	 (with-current-buffer location
	   (goto-char (point-max))
	   (newline)
	   (insert-file-contents file nil 67)
	   (zetteldesk--replace-title)))
       (zetteldesk-insert-switch-to-scratch arg))

     (defun zetteldesk-insert-node-contents-without-link ()
       "\"Sister function\" of `zetteldesk-insert-node-contents'.
     Finds a node that is part of the `zetteldesk-desktop' and inserts its
     contents to the bottom of the zetteldesk-scratch buffer. This
     function differentiates itself, by the fact that it doesn't
     insert an ID link to the node in the current buffer and by the
     fact that it switches to the scratch buffer in a split without
     needing a `\\[universal-argument]'.

     For me, it makes sense a lot of the time to insert a link to the
     node inthe current buffer, especially if its an outlining
     buffer. But sometimes its not handy, and so, I just made this
     second iteration to fix that issue."
       (interactive)
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	      (location (zetteldesk-insert-location))
	      (file (org-roam-node-file node)))
	 (with-current-buffer location
	   (goto-char (point-max))
	   (newline)
	   (insert-file-contents file nil 67)
	   (zetteldesk--replace-title)))
       (switch-to-buffer-other-window "*zetteldesk-scratch*"))

     (defun zetteldesk-insert-org-file-contents (&optional arg)
       "Select an org buffer that is in the `zetteldesk-desktop'.
     Insert its contents to the *zetteldesk-scratch* buffer, make its
      title a top level heading and demote all of its headings by one
      level (since the title now acts as a top level heading).  Note
      that org-roam nodes are not shown

     Optional argument ARG, if given needs to be a
     `\\[universal-argument]' and it switches to the *zetteldesk-scratch*
     buffer in a split"
       (interactive "P")
       (let* ((buffer (set-buffer (read-buffer "Zetteldesk Buffers: " nil nil #'zetteldesk-org-buffer-p)))
	      (location (zetteldesk-insert-location))
	      (file (buffer-file-name buffer)))
	 (set-buffer location)
	 (goto-char (point-max))
	 (save-excursion
	   (newline)
	   (insert-file-contents file))
	 (save-excursion
	   (while (not (org-next-visible-heading 1))
	     (org-metaright)))
	 (zetteldesk--replace-title))
       (zetteldesk-insert-switch-to-scratch arg))

     (defun zetteldesk-insert-link-to-pdf (&optional arg)
       "Select a pdf file that is part of the `zetteldesk-desktop'.
     Prompt for a page in that pdf (defaults to page 1 if you don't
     care about the page).

     Then, in the zetteldesk-scratch buffer, insert at `point-max' a
     newline and then a new heading with its name consisting of the
     string \"Supportive Material - \" then the pdfs name, without the
     file structure or the extension and then the string
     \"(PDF)\".  Then, insert a newline, the string \"Link to PDF: \"
     and then a link to the chosen pdf, in the correct page, with the
     description being the pdfs name without the file structure or the
     extension.  Note that `org-pdftools-setup-link' needs to be run
     for pdf links to work (which this uses).

     Optionally, if given optional argument ARG which is the
     `\\[universal-argument]' save the highlighted region in a
     variable and insert it after the heading but before the pdf link.
     This functionality serves the purpose of adding a \"description\"
     sort of thing to the pdf. Typically, when citing a pdf as
     supplementary info to an argument, there is something specific
     you want to take from the pdf. Therefore, this optional addition,
     adds that to the scratch buffer so you remember why it was
     useful."
       (interactive "P")
       (let* ((pdf-buffer (set-buffer (read-buffer "Zetteldesk Pdfs: " nil nil #'zetteldesk-pdf-p)))
	      (file (buffer-file-name pdf-buffer))
	      (location (zetteldesk-insert-location))
	      (page (read-from-minibuffer "Page: " "1"))
	      (description (file-name-nondirectory (file-name-sans-extension file))))
	 (with-current-buffer location
	   (goto-char (point-max))
	   (newline)
	   (org-insert-heading)
	   (insert "Supportive Material - " description " (PDF)")
	   (newline)
	   (when (equal arg '(4))
	     (let ((contents (buffer-substring (mark) (point))))
	       (insert contents)
	       (newline)))
	   (insert "Link to PDF: "
		   (org-link-make-string
		    (concat "pdf:" file "::" page)
		    description)))))


   #+END_SRC

   #+RESULTS:
   : zetteldesk-insert-link-to-pdf

** Save the state of the zetteldesk
Saving the current state of the ~zetteldesk-desktop~ could be a very useful feature. This code tries to implement this feature to zetteldesk.el. The function ~zetteldesk-save-state~ saves the state of a desktop with an identifier for it by adding the code to add it to the list ~zetteldesk-saved-states~ to an elisp file that should be in your load-path and required in your init.el. Then, the desktop can be restored using ~zetteldesk-restore-desktop~ in a new session.

#+BEGIN_SRC elisp :tangle zetteldesk.el

  (defcustom zetteldesk-saved-states '()
    "List of lists of buffers storing saved states of `zetteldesk-desktop'.

  Each item in the list is a list of buffers. The function
  `zetteldesk-save-state' inserts the code to add the list of
  buffers currently in the `zetteldesk-desktop' to this list."
    :type 'list
    :group 'zetteldesk)

  (defcustom zetteldesk-saved-state-file
    (concat user-emacs-directory "libs/zetteldesk-saves.el")
    "Location in which zetteldesk.el saves its desktops.

  Saving is done with `zetteldesk-save-state' and is stored in this
  file so it can be restored in later sessions with
  `zetteldesk-restore-desktop'."
    :type 'string
    :group 'zetteldesk)

  (defun zetteldesk-p* (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk-desktop'."
    (not (equal zetteldesk-desktop-default
		(buffer-local-value 'zetteldesk-desktop BUFFER))))

  (defun zetteldesk-buffer-list ()
    "Make a list of all buffers that are part of the current `zetteldesk-desktop'.

  Also prompt for the identifier of the desktop so it can be
  recognized. This function is not meant to be used directly but be
  passed to `zetteldesk-save-state'. The identifier is to be used
  when restoring the desktop with `zetteldesk-restore-desktop'."
    (let ((identifier (read-string "Identifier for desktop: ")))
      (cons identifier
	    (cl-loop for buffer in (buffer-list)
		     if (zetteldesk-p* buffer)
		     collect (buffer-file-name buffer)))))

  (defun zetteldesk-save-state ()
    "Save the state of the current `zetteldesk-desktop'.

  This function uses `zetteldesk-buffer-list' as its main helper
  function. It collects a list of files who are part of the curent
  `zetteldesk-desktop' and adds an identifier to them so the state
  can be later restored. What it does is insert an `add-to-list'
  statement to the file that `zetteldesk-saved-state-file' points
  to, which adds the contents of the list returned by
  `zetteldesk-buffer-list' to `zetteldesk-saved-states'.

  If `zetteldesk-saved-state-file' is required in your init.el,
  zetteldesk will remember your saved states and it will be able to
  restore them with `zetteldesk-restore-desktop'."
    (interactive)
    (with-current-buffer (find-file-noselect zetteldesk-saved-state-file)
      (goto-char (point-max))
      (previous-line)
      (insert (format "%S" `(add-to-list 'zetteldesk-saved-states ',(zetteldesk-buffer-list))))
      (newline)
      (save-buffer)))

  (defun zetteldesk-add-file-to-desktop (FILE)
    "Add FILE to the current `zetteldesk-desktop'.

  If FILE is not associated to a buffer, read it in a buffer and
  add the resulting buffer to the `zetteldesk-desktop'. This
  function is not meant to be used interactively as it would be
  impractical. It is primarily for use in
  `zetteldesk-restore-desktop'."
    (let ((buffer (get-file-buffer FILE))
	  (org-startup-with-latex-preview nil))
      (if buffer
	  (zetteldesk--add-buffer buffer)
	(zetteldesk--add-buffer (find-file-noselect FILE)))))

  (defun zetteldesk-restore-desktop ()
    "Restore a saved state of the `zetteldesk-desktop'.

  The state must be saved to `zetteldesk-saved-states' using
  `zetteldesk-save-state' and the user is prompted to select a
  state using its identifier."
    (interactive)
    (mapcar #'zetteldesk-add-file-to-desktop
	    (cdr (assoc (completing-read "Save-State: " zetteldesk-saved-states)
			zetteldesk-saved-states))))

#+END_SRC
   
** Multiple scratches
The idea of having multiple zetteldesk-scratch buffers in one session and being able to select which is active or not in a given time is an interesting concept as mentioned in an issue. It simulates having multiple desks and placing different things in each. I personally haven't found the need for it, but it makes sense why it would be useful.

Multiple desktops means a few things:

- First write the current desktop to a file (write-file)
- Run the scratch initialization function to create a new desktop (zetteldesk--create-scratch-buffer)
- Store the old one in a variable
- Have a function to switch between desktops

  The first three can be done with the same top level function. Out of the three, only the third needs to be written here. Of the function below, the first is this implementation, while the other two are switching functions with different behaviour on the current scratch.

#+BEGIN_SRC elisp :tangle zetteldesk.el

  (defcustom zetteldesk-scratch-list '()
    "List of saved zetteldesk-scratch buffers.

  Each item in this list is added to it via the functions
  `zetteldesk-create-new-desktop' or
  `zetteldesk-store-active-desktop-and-switch' and is a buffer name
  of an inactive zetteldesk-scratch buffer that those functions
  saved."
    :type 'list
    :group 'zetteldesk)

  (defun zetteldesk-create-new-scratch (file)
    "Create a new zetteldesk-scratch buffer.

  This function initially prompts for a file to write the current
  zetteldesk-scratch to so it is not lost when replacing it.  It
  then stores its name and file as a cons cell to
  `zetteldesk-scratch-list'.  Finally, it creates a new
  zetteldesk-scratch buffer, with the low-level
  `zetteldesk--create-scratch-buffer' function, which is empty."
    (interactive "F")
    (let* ((name (read-string "Name of old desktop: "))
	   (cell (cons name file)))
      (with-current-buffer "*zetteldesk-scratch*"
	(write-file file))
      (push cell zetteldesk-desktop-list)
      (zetteldesk--create-scratch-buffer)))

  (defun zetteldesk-store-active-scratch-and-switch (file)
    "Store the active zetteldesk-scratch buffer and switch to an inactive one.

  This function initializes with `zetteldesk-create-new-scratch'
  but inserts the contents of an inactive scratch to the newly
  initialized one instead of keeping it empty.

  The function prompts the user for an inactive zetteldesk-scratch
  stored in `zetteldesk-scratch-list' and inserts its contents to
  the new zetteldesk-scratch, making it the active
  zetteldesk-scratch buffer."
    (interactive "F")
    (zetteldesk-create-new-scratch file)
    (with-current-buffer "*zetteldesk-scratch*"
      (insert-file-contents (cdr (assoc
				  (completing-read "Select desktop to activate: "
						   zetteldesk-desktop-list)
				  zetteldesk-desktop-list)))))

  (defun zetteldesk-delete-active-scratch-and-switch ()
    "Switch the active zetteldesk-scratch buffer deleting the current.

  This function is a sister function of
  `zetteldesk-store-active-desktop-and-switch' with their main
  difference being that this function deletes the current
  zetteldesk-scratch with `erase-buffer' and replaces it with the
  one selected from `zetteldesk-scratch-list'.

  This function is useful when the current zetteldesk-scratch has
  already been saved to `zetteldesk-scratch-list' and you want to
  switch to an inactive one as in that case there is no point to
  re-store it to `zetteldesk-scratch-list'.  Another reason to use
  this is if the scratch is currently empty and you want to fill it
  up."
    (interactive)
    (with-current-buffer "*zetteldesk-scratch*"
      (erase-buffer)
      (insert-file-contents (cdr (assoc
				  (completing-read "Select desktop to activate: "
						   zetteldesk-desktop-list)
				  zetteldesk-desktop-list)))))

#+END_SRC

* Keybindings
This section is for the default keybindings of zetteldesk.el, implemented in a seperate file zetteldesk-kb.el. I personally don't use these but they are very useful to have

#+BEGIN_SRC elisp :tangle zetteldesk-kb.el

  ;;; zetteldesk-kb.el --- Keybindings for zetteldesk.el  -*- lexical-binding: t; -*-

  ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
  ;; Maintainer: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
  ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk-kb.el
  ;; Package-Requires: ((zetteldesk "1.0.1") (hydra "0.15") (major-mode-hydra "0.2") (emacs "24.1"))
  ;; Created: 3rd March 2022
  ;; License: GPL-3.0
  ;; Version: 0.3

  ;; This file is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; For a full copy of the GNU General Public License
  ;; see <https://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; This file defines a few hydras for the keybindings in
  ;; zetteldesk.el.  The hydra displays small descriptions of each
  ;; function to help a beginner with getting familiarised with the
  ;; package.  The keybindings used are based on what my personal config
  ;; uses, but to fit it all in a single hydra, there are some
  ;; differentiations.

  ;; I made this optional and not part of the main package as I don't
  ;; consider it essential, just helpful for those who want a ready set
  ;; of keybindings, with descriptions instead of the function names to
  ;; try the package out.  Due to the modularity of Emacs, I recommend
  ;; you set up your own keybindings either from scratch or by
  ;; customising these hydras so they make the most sense to you and fit
  ;; your mental model.  I however thought that something like this will
  ;; be very useful until you get the hang of the package.

  ;; The hydras are defined with the `pretty-hydra-define' macro from
  ;; the `major-mode-hydra' package as imo its end result is a very good
  ;; looking hydra menu, perfect for something like this.  For this
  ;; reason, this part of the package, relies on that package.

  ;;; Code:

  ;; Dependencies

  (require 'zetteldesk)
  (require 'hydra)
  (require 'pretty-hydra)
  ;; There is also org-roam, but since this requires zetteldesk.el to be
  ;; loaded, that one should handle loading org-roam

  ;; Supplementary Hydras

  (pretty-hydra-define zetteldesk-add-hydra (:color blue :title "Add to Zetteldesk")
    ("Org-Roam"
     (("n" zetteldesk-add-node-to-desktop "Add Node")
      ("b" zetteldesk-add-backlinks-to-desktop "Add Current Node + All its backlinks")
      ("p" zetteldesk-add-poi-or-moc-backlink-to-desktop "Select MOC or POI - Add one of its backlinks"))

     "Other"
     (("a" zetteldesk-add-to-desktop "Add Buffer"))))

  (pretty-hydra-define zetteldesk-remove-hydra (:color blue :title "Remove from Zetteldesk")
    ("Org-Roam"
     (("n" zetteldesk-remove-node-from-desktop "Remove Node")
      ("b" zetteldesk-remove-backlinks-from-desktop "Remove Current Node + All its backlinks"))

     "Other"
     (("r" zetteldesk-remove-from-desktop "Remove Buffer"))))

  (pretty-hydra-define zetteldesk-insert-hydra (:color blue :title "Insert from the Zetteldesk")
    ("Org-Roam"
     (("n" zetteldesk-insert-node-contents "Link to Node and Contents in *zetteldesk-scratch*")
      ("N" zetteldesk-insert-node-contents-without-link "Node Contents in *zetteldesk-scratch")
      ("i" zetteldesk-node-insert "Link to Node")
      ("b" zetteldesk-node-insert-sort-backlinks "Link to Node - Menu sorted by Backlinks")
      ("m" zetteldesk-node-insert-if-poi-or-moc "Links to all POIs and MOCs"))

     "Supplementary Material to *zetteldesk-scratch*"
      (("p" zetteldesk-insert-link-to-pdf "Link to PDF")
       ("o" zetteldesk-insert-org-file-contents "Org File Contents"))))

  (pretty-hydra-define zetteldesk-scratch-hydra (:color blue :title "Zetteldesk Scratch functions")
    ("Switch to Existing Scratch"
     (("s" zetteldesk-switch-to-scratch-buffer "Switch to *zetteldesk-scratch*"))

     "Manipulate the Zetteldesk-scratch"
     (("c" zetteldesk-create-new-scratch "Create a new *zetteldesk-scratch*")
      ("a" zetteldesk-store-active-scratch-and-switch "Switch to an inactive scratch storing the existing one")
      ("d" zetteldesk-delete-active-scratch-and-switch "Switch to an inactive scratch deleting the existing one"))))

  ;; The Primary Hydra

  (pretty-hydra-define zetteldesk-main-hydra (:color blue :title "Zetteldesk Hydra")
    ("Filter Functions"
     (("b" zetteldesk-switch-to-buffer "Switch to Zetteldesk Buffer")
      ("n" zetteldesk-node-find "Find Zetteldesk Node"))

     "Add/Remove Hydras"
     (("r" zetteldesk-remove-hydra/body "Run the Removing Hydra")
      ("a" zetteldesk-add-hydra/body "Run the Adding Hydra"))

     "Inserting Things and *zetteldesk-scratch*"
     (("s" zetteldesk-scratch-hydra/body "Run the Scratch Hydra")
      ("i" zetteldesk-insert-hydra/body "Run the Insert Hydra"))

     "Saving/Restoring the Desktop"
     (("S" zetteldesk-save-state "Save the current zetteldesk-desktop")
      ("R" zetteldesk-restore-desktop "Restore a saved zetteldesk-desktop"))))

  ;; Set up the keybinding to call the hydra

  (defcustom zetteldesk-kb-hydra-prefix (kbd "C-c .")
    "Stores the value of the keybinding that calls the main zetteldesk hydra."
    :type 'string
    :group 'zetteldesk)

  (defvar zetteldesk-kb-map
    (let ((km (make-sparse-keymap)))
      (define-key km zetteldesk-kb-hydra-prefix #'zetteldesk-main-hydra/body) km))

  ;; Local variables:
  ;; byte-compile-docstring-max-column: 100
  ;; end:

#+END_SRC

   
* Org-remark integration
** Preamble
#+BEGIN_SRC elisp :tangle zetteldesk-remark.el
  ;;; zetteldesk-remark.el --- Org-Remark integration for zetteldesk.el   -*- lexical-binding: t; -*-

  ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
  ;; Maintainer: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
  ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk-remark.el
  ;; Package-Requires: ((zetteldesk "1.0") (org-remark "1.0") (emacs "27.2"))
  ;; Created: 22nd March 2022
  ;; License: GPL-3.0
  ;; Version: 0.2

  ;; This file is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; For a full copy of the GNU General Public License
  ;; see <https://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; This file defines some functions for zetteldesk.el which help with
  ;; integrating it with org-remark.  Org-remark requires the buffer from
  ;; which its called to be associated with a file.  However the
  ;; zetteldesk-scratch buffer is not associated with a file.  Therefore,
  ;; some special things need to be done to allow for this integration
  ;; to work.  However, I consider that this is a good implementation of
  ;; such behaviour.

  ;;; Code:

  (require 'zetteldesk)
  (require 'org-remark)

#+END_SRC

** Code
   Org-remark is a package for highlighting parts of a document and creating marginal notes from them. I believe that such a feature is great for an environment such as the zetteldesk-scratch buffer. But as that buffer is not associated to a file, I want to setup better integration between it and zetteldesk.

   Namely, I am mostly looking for two things to work as I want them. Be able to create margin notes from the zetteldesk-scratch buffer without it being associated to a file, by let-binding the value of ~org-remark-notes-file-name~ to an absolute path, probably of the form of org-roam-directory/zetteldesk-margin-notes.org or something. Then, if I decide I want to save this zetteldesk to a file, the margin-notes should be linked there correctly (might happen by default, however I am uncertain).

   Furthermore, I want to make sure the behaviour is as intended when having multiple margin notes from zetteldesks. This heading will tangle to a seperate file which will be a zetteldesk extension.

   #+BEGIN_SRC elisp :tangle zetteldesk-remark.el

     ;; -- Helper Functions/Variables --

     (defcustom zetteldesk-remark-title nil
       "Title to use in `zetteldesk-remark-highlight-get-title'.

     Initialised to nil and given a value when turning on
     `zetteldesk-remark-mode' through `zetteldesk-remark-set-title'."
       :type 'string
       :group 'zetteldesk)

     (defcustom zetteldesk-remark-notes-file
       (concat org-roam-directory "zetteldesk-margin-notes.org")
       "Default value of `org-remark-notes-file-name' for zetteldesk functions.

     When turning on `zetteldesk-remark-mode' this variable's value is
     set to the value of `org-remark-notes-file-name' through
     `zetteldesk-remark-set-notes-file'.  This is stored as a variable
     so you can customise it if you don't like its default value."
       :type 'string
       :group 'zetteldesk)

     (defconst zetteldesk-remark-default-notes "marginalia.org"
       "Constant that stores the default value of `org-remark-notes-file-name'.

     Zetteldesk-remark, for its own purposes changes the value of that
     variable with `zetteldesk-remark-set-notes-file' to make it more
     sensible in its own workflow.  However, the original value needs
     to be restored after the package is done.  For this reason this
     constant stores that value.")

     (defun zetteldesk-remark-set-title ()
       "Set the value of `zetteldesk-remark-title' from a minibuffer prompt."
       (setq zetteldesk-remark-title (read-string "Zetteldesk Remark Title: ")))

     (defun zetteldesk-remark-set-notes-file ()
       "Helper function to set `org-remark-notes-file-name''s value.

     This is the value the zetteldesk-remark functions expect and this
     function is run when `zetteldesk-remark-mode' is turned on."
       (setq org-remark-notes-file-name zetteldesk-remark-notes-file))

     (defun zetteldesk-remark-reset-notes-file ()
       "Reset `org-remark-notes-file-name' to its default value.

     This is a helper function for zetteldesk-remark to reset the
     value of that variable after turning off
     `zetteldesk-remark-mode'."
       (setq org-remark-notes-file-name zetteldesk-remark-default-notes))

     ;;;###autoload
     (define-minor-mode zetteldesk-remark-mode
       "Toggle the `zetteldesk-remark-mode'.

     This mode initialises the value of `zetteldesk-remark-title', an
     important variable for using org-remark in buffers not associated
     to a file."
       :init-value nil
       :global t
       :group 'zetteldesk
       :lighter " zetteldesk-remark"
       (if zetteldesk-remark-mode
	   (progn (zetteldesk-remark-set-notes-file)
		  (zetteldesk-remark-set-title))
	 (zetteldesk-remark-reset-notes-file)))

     (defun zetteldesk-remark-top-level-heading-title ()
       "Get the title of the top-level org heading.

     This is a helper function for `zetteldesk-remark-highlight-mark'.
     That function assumes that the heading's title is the title of a
     node, which is true only for top level headings in
     ,*zetteldesk-scratch*.  This ensures that the title it takes is
     always that of a top level heading."
       (save-excursion
	 (while (not (= (car (org-heading-components)) 1))
	   (org-previous-visible-heading 1))
	 (nth 4 (org-heading-components))))

     (defun zetteldesk-remark-highlight-get-title ()
       "Variation of `org-remark-highlight-get-title' for zetteldesk-remark.el.

     If the buffer is not associated to a file name, this function
     should not return nil, but the value of
     `zetteldesk-remark-title'.  This is to be able to use
     `zetteldesk-remark-mark' in the *zetteldesk-scratch*."
       (if (buffer-file-name)
	   (or (cadr (assoc "TITLE" (org-collect-keywords '("TITLE"))))
	       (file-name-sans-extension
		(file-name-nondirectory (buffer-file-name))))
	 zetteldesk-remark-title))

     (defun zetteldesk-remark-highlight-save
	 (filename beg end props &optional title node-title)
       "Variation of `org-remark-highlight-save' for zetteldesk-remark.el.

     It has a bonus optional parameter NODE-TITLE which acts as the
     name of the second level heading which will store the item and to
     not completely lose the items that were marked during the call to
     `zetteldesk-remark-mark' they are placed in a quote block right
     after the second level heading.  Besides that it acts the same as
     `org-remark-highlight-save'.  However,
     `zetteldesk-remark-highlight-mark' the function that calls this,
     gives it quite different arguments than
     `org-remark-highlight-mark' would.  For more details refer to its
     docstring.

     FILENAME, BEG, END, PROPS and TITLE are the same as in
     `org-remark-highlight-save'."
       (let* ((filename (org-remark-source-get-file-name filename))
	      (id (plist-get props 'org-remark-id))
	      (text (org-with-wide-buffer (buffer-substring-no-properties beg end)))
	      (notes-buf (find-file-noselect (org-remark-notes-get-file-name)))
	      (main-buf (current-buffer))
	      (line-num (org-current-line beg))
	      (orgid (org-remark-highlight-get-org-id beg)))
	 (with-current-buffer notes-buf
	   ;;`org-with-wide-buffer is a macro that should work for non-Org file'
	   (org-with-wide-buffer
	    (let ((file-headline (or (org-find-property
				      org-remark-prop-source-file filename)
				     (progn
				       ;; If file-headline does not exist,
				       ;; create one at the bottom
				       (goto-char (point-max))
				       ;; Ensure to be in the beginning of
				       ;; line to add a new headline
				       (when (eolp) (open-line 1) (forward-line 1) (beginning-of-line))
				       (insert "* " title "\n")
				       (org-set-property org-remark-prop-source-file filename)
				       (org-up-heading-safe) (point))))
		  (id-headline (org-find-property org-remark-prop-id id)))
	      ;; Add org-remark-link with updated line-num as a property
	      (plist-put props "org-remark-link" (concat
						  "[[file:"
						  filename
						  (when line-num (format "::%d" line-num))
						  "]]"))
	      (if id-headline
		  (progn
		    (goto-char id-headline)
		    ;; Update the existing headline and position properties
		    ;; Don't update the headline text when it already exists
		    ;; Let the user decide how to manage the headlines
		    ;; (org-edit-headline text)
		    ;; FIXME update the line-num in a normal link if any
		    (org-remark-notes-set-properties beg end props))
		;; No headline with the marginal notes ID property. Create a new one
		;; at the end of the file's entry
		(goto-char file-headline)
		(org-narrow-to-subtree)
		(goto-char (point-max))
		;; Ensure to be in the beginning of line to add a new headline
		(when (eolp) (open-line 1) (forward-line 1) (beginning-of-line))
		;; Create a headline
		;; Add a properties
		(insert "** " node-title "\n")
		(insert "#+begin_quote\n" text "\n" "#+end_quote\n")
		(org-remark-notes-set-properties beg end props)
		(when (and orgid org-remark-use-org-id)
		    (insert "[[id:" orgid "]" "[" title "]]")))))
	   (cond
	    ;; fix GH issue #19
	    ;; Temporarily remove `org-remark-save' from the `after-save-hook'
	    ;; When the marginal notes buffer is the main buffer
	    ((eq notes-buf main-buf)
	     (remove-hook 'after-save-hook #'org-remark-save t)
	     (save-buffer)
	     (add-hook 'after-save-hook #'org-remark-save nil t))
	    ;; When marginal notes buffer is separate from the main buffer, save the
	    ;; notes buffer
	    ((buffer-modified-p)
	     (save-buffer)))
	   t)))

     ;; -- The main functions --

     (defun zetteldesk-remark-highlight-mark
	 (beg end &optional id mode label face properties)
       "Variation of `org-remark-highlight-mark' for zetteldesk-remark.el.

     The main difference is that the zetteldesk alternative to some of
     the org-remark functions are run.  This
     `zetteldesk-remark-highlight-save' instead of
     `org-remark-highlight-save' and
     `zetteldesk-remark-highlight-get-title' instead of
     `org-remark-highlight-get-title'.  Also, when ran, this function
     activates `zetteldesk-remark-mode' which runs some useful
     initialization functions that other functions of the package
     expect.

     In running the function, filename is no longer taken from the
     function `buffer-file-name' but from the node whose title is the
     current heading's title, the title is a `concat' of the string
     ,*zetteldesk-scratch* and the value of
     `zetteldesk-remark-highlight-get-title'.  Lastly, this gives
     `zetteldesk-remark-highlight-save''s final argument which is the
     title of the node that is associated with this section.

     This function is meant to be run in the *zetteldesk-scratch*
     buffer so evalutating it elsewhere might lead to errors.  For
     regular buffers associated to a file you should just use the
     default `org-remark-highlight-mark' as this version relies
     heavlily on the structure of *zetteldesk-scratch*.

     Arguments BEG, END, ID, MODE, LABEL, FACE and PROPERTIES are all
     identical to those in `org-remark-highlight-mark'."
       ;; Ensure to turn on the local minor mode
       (unless org-remark-mode (org-remark-mode +1)
	       zetteldesk-remark-mode (zetteldesk-remark-mode +1))
       ;; When highlights are toggled hidden, only the new one gets highlighted in
       ;; the wrong toggle state.
       (when org-remark-highlights-hidden (org-remark-highlights-show))
       ;; Add highlight to the text
       (org-with-wide-buffer
	(let ((ov (make-overlay beg end nil :front-advance))
	      ;; UUID is too long; does not have to be the full length
	      (id (if id id (substring (org-id-uuid) 0 8))))
	  (overlay-put ov 'face (if face face 'org-remark-highlighter))
	  (while properties
	    (let ((prop (pop properties))
		  (val (pop properties)))
	      (overlay-put ov prop val)))
	  (when label (overlay-put ov 'org-remark-label label))
	  (overlay-put ov 'org-remark-id id)
	  ;; Keep track of the overlay in a local variable. It's a list that is
	  ;; guaranteed to contain only org-remark overlays as opposed to the one
	  ;; returned by `overlay-lists' that lists any overlays.
	  (push ov org-remark-highlights)
	  ;; for mode, nil and :change result in saving the highlight.  :load
	  ;; bypasses save.
	  (unless (eq mode :load)
	    (let* ((node-title (zetteldesk-remark-top-level-heading-title))
		   (node (org-roam-node-from-title-or-alias node-title))
		   (filename (org-roam-node-file node)))
	      (if filename
		  (zetteldesk-remark-highlight-save filename
						    beg end
						    (overlay-properties ov)
						    (concat "*zetteldesk-scratch* "
							    (zetteldesk-remark-highlight-get-title))
						    node-title)
		(message "org-remark: Highlights not saved; buffer is not visiting a file"))))))
       (deactivate-mark)
       (org-remark-highlights-housekeep)
       (org-remark-highlights-sort))

     (defun zetteldesk-remark-mark (beg end &optional id mode)
       "Variation of `org-remark-mark' for zetteldesk-remark.el.

     The only difference is that `zetteldesk-remark-highlight-mark' is
     run instead of `org-remark-highlight-mark'.  For details on what
     the differences are, refer to its docstring, while for details
     on the arguments BEG, END, ID and MODE refer to
     `org-remark-mark'."
       (interactive (org-remark-region-or-word))
       ;; FIXME
       ;; Adding "nil" is different to removing a prop
       ;; This will do for now
       (zetteldesk-remark-highlight-mark beg end id mode
					 nil nil
					 (list "org-remark-label" "nil")))

     (defun zetteldesk-remark-switch-to-margin-notes ()
       "Helper function to go to the zetteldesk-margin-notes file.

     If `org-remark-mark' is called through its wrapper function
     `zetteldesk-remark-mark', it sets `org-remark-notes-file-name' to
     a specific file, which is meant to be used with all margin notes
     coming from zetteldesk-scratch.  This function switches to that
     file."
       (interactive)
       (pop-to-buffer (find-file zetteldesk-remark-notes-file)))
   #+END_SRC

   #+RESULTS:
   : zetteldesk-remark-switch-to-margin-notes
     
* Handling notes on articles better - Literature Notes
   This section is about zetteldesk-ref, an optional extension of zetteldesk.el. It includes integratio nof the zetteldesk with various reference sources such as bibtex entry nodes, which are org-roam nodes, however they need a different behaviour than your typical org-roam node.
   
** Preamble
    This is just the intro text that needs to be in the start of the file

    #+BEGIN_SRC elisp :tangle zetteldesk-ref.el
      ;;; zetteldesk-ref.el --- A zetteldesk extension for interfacing with literature nodes   -*- lexical-binding: t; -*-

      ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
      ;; Maintainer: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
      ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk-ref.el
      ;; Package-Requires: ((zetteldesk "1.0") (bibtex-completion "1.0") (emacs "26.1"))
      ;; Created: 27th March 2022
      ;; License: GPL-3.0
      ;; Version: 0.2

      ;; This file is free software; you can redistribute it and/or modify
      ;; it under the terms of the GNU General Public License as published by
      ;; the Free Software Foundation; either version 3, or (at your option)
      ;; any later version.

      ;; This program is distributed in the hope that it will be useful,
      ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
      ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      ;; GNU General Public License for more details.

      ;; For a full copy of the GNU General Public License
      ;; see <https://www.gnu.org/licenses/>.

      ;;; Commentary:

      ;; This package provides some optional improvements to zetteldesk.el.
      ;; Specifically it introduces mechanisms for handling literature notes
      ;; associated to a bibtex entry which are mostly powered by org-noter.
      ;; This code makes these reference materials interface better with the
      ;; zetteldesk

      ;;; Code:

      (require 'zetteldesk)
      (require 'bibtex-completion)

      (declare-function ivy-bibtex "ext:ivy-bibtex.el")
      (declare-function helm-bibtex "ext:helm-bibtex.el")
    #+END_SRC
    
** Reference notes from Bibtex Entries
    I have a decent amount of notes that are on scientific articles taken with ~org-noter~. These are org-roam nodes, but they need a special behaviour imo as their formatting isn't similar to that of my permanent notes. Now, gathering these nodes to make a special filter function including only those was an adventure in and of itself. But it was a chance to get more familiarized with common lisp loops, which are a very powerful system.

   #+BEGIN_SRC elisp :tangle zetteldesk-ref.el

     ;; -- Reference Nodes from Bibtex Entries --
     (defun zetteldesk-ref-note-refs-p ()
       "Predicate function to find all bibtex completion candidates with a note.

     Checks if every candidate has the \"=has-note=\" tag using
     `assoc' and if it does, collects that candidate."
       (cl-loop for ref in (bibtex-completion-candidates)
		if (assoc "=has-note=" ref)
		collect ref))

     (defun zetteldesk-ref-citekey-from-refs ()
       "Find the \"=key=\" tag from a list of candidates.

     The list is collected with `zetteldesk-ref-note-refs-p' which is a
     list of candidates that have notes. Collects it using `assoc'."
       (cl-loop for ref in (zetteldesk-ref-note-refs-p)
		collect (assoc "=key=" ref)))

     (defun zetteldesk-ref-citekey-from-node ()
       "Collects the citekeys of org-roam-nodes in the `zetteldesk-desktop'.

     Ignores nodes for which `org-roam-node-refs' returns nil."
       (let* ((init-list (org-roam-node-list))
	      (zetteldesk-nodes (cl-remove-if-not #'zetteldesk-node-p init-list)))
	 (cl-loop for node in zetteldesk-nodes
		  if (org-roam-node-refs node)
		  collect (car (org-roam-node-refs node)))))

     (defun zetteldesk-ref-node-from-refs ()
       "Collects a list of ref nodes.

     The nodes are collected from their citekey using
     `org-roam-node-from-ref', while the citekeys themselves are
     collected from `zetteldesk-ref-citekey-from-refs'."
       (cl-loop for ref in (zetteldesk-ref-citekey-from-refs)
		collect (org-roam-node-from-ref (concat "cite:" (cdr ref)))))

     (defun zetteldesk-ref-roam-node-read--completions* (node-list &optional filter-fn sort-fn)
       "Run `org-roam-node-read--completions' with NODE-LIST being a list of nodes.

     Typically, the function takes `org-roam-node-list' as the initial
     list of nodes and creates the alist `org-roam-node-read'
     uses.  However, it can be helpful to supply the list of nodes
     yourself, when the predicate function used cannot be inferred
     through a filter function of the form this function
     takes.  FILTER-FN and SORT-FN are the same as in
     `org-roam-node-read--completions'.  The resulting alist is to be
     used with `zetteldesk-ref-roam-node-read*'."
       (let* ((template (org-roam-node--process-display-format org-roam-node-display-template))
	      (nodes node-list)
	      (nodes (mapcar (lambda (node)
			       (org-roam-node-read--to-candidate node template)) nodes))
	      (nodes (if filter-fn
			 (cl-remove-if-not
			  (lambda (n) (funcall filter-fn (cdr n)))
			  nodes)
		       nodes))
	      (sort-fn (or sort-fn
			   (when org-roam-node-default-sort
			     (intern (concat "org-roam-node-read-sort-by-"
					     (symbol-name org-roam-node-default-sort))))))
	      (nodes (if sort-fn (seq-sort sort-fn nodes)
		       nodes)))
	 nodes))

     (defun zetteldesk-ref-roam-node-read* (node-list &optional initial-input filter-fn sort-fn require-match prompt)
       "Run `org-roam-node-read' with the nodes supplied by NODE-LIST.

     NODE-LIST is a list of nodes passed to
     `zetteldesk-ref-roam-node-read--completions*', which creates an alist of
     nodes with the proper formatting to be used in this
     function.  This is for those cases where it is helpful to use your
     own list of nodes, because a predicate function can not filter
     them in the way you want easily.

     INITIAL-INPUT, SORT-FN, FILTER-FN, REQUIRE-MATCH, PROMPT are the
     same as in `org-roam-node-read'."
       (let* ((nodes (zetteldesk-ref-roam-node-read--completions* node-list filter-fn sort-fn))
	      (prompt (or prompt "Node: "))
	      (node (completing-read
		     prompt
		     (lambda (string pred action)
		       (if (eq action 'metadata)
			   `(metadata
			     ;; Preserve sorting in the completion UI if a sort-fn is used
			     ,@(when sort-fn
				 '((display-sort-function . identity)
				   (cycle-sort-function . identity)))
			     (annotation-function
			      . ,(lambda (title)
				   (funcall org-roam-node-annotation-function
					    (get-text-property 0 'node title))))
			     (category . org-roam-node))
			 (complete-with-action action nodes string pred)))
		     nil require-match initial-input 'org-roam-node-history)))
	 (or (cdr (assoc node nodes))
	     (org-roam-node-create :title node))))

     (defun zetteldesk-ref-add-node-to-desktop (NODE)
       "Add NODE to the `zetteldesk-desktop'.

     NODE is a literature note that is part of the org-roam
     repository.  The list of such nodes is gathered with
     `zetteldesk-ref-node-from-refs'."
       (interactive (list (zetteldesk-ref-roam-node-read* (zetteldesk-ref-node-from-refs))))
       (let ((buffer (org-roam-node-buffer NODE))
	     (file (org-roam-node-file NODE))
	     (org-startup-with-latex-preview nil))
	 (if buffer
	     (zetteldesk--add-buffer buffer)
	   (zetteldesk--add-buffer (find-file-noselect file)))))

     (defun zetteldesk-ref-remove-node-from-desktop (NODE)
       "Remove NODE from the `zetteldesk-desktop'.

     NODE is a literature note that is currently part of the
     zetteldesk, meaning its part of the list generated by
     `zetteldesk-ref-node-from-refs'."
       (interactive
	(list (zetteldesk-ref-roam-node-read* (zetteldesk-ref-node-from-refs) nil #'zetteldesk-node-p)))
       (let ((buffer (org-roam-node-buffer NODE)))
	 (zetteldesk--remove-buffer buffer)))

     (defun zetteldesk-ref-find-ref-node ()
       "Execute a filtered version of `ivy-bibtex-with-notes' in an org-roam UI.

     This does not exactly run `ivy-bibtex-with-notes' as that doesn't
     have a way to filter things.  It collects a list of nodes which
     are reference nodes linked to a bibtex entry through
     `zetteldesk-ref-node-from-refs' and passes it to
     `zetteldesk-ref-roam-node-read*' which is a modified version of
     `org-roam-node-read' which takes a list of nodes as an
     argument.  Since this required a rewrite of `org-roam-node-read',
     finding the file is done indirectly and not through
     `org-roam-node-file'."
       (interactive)
       (find-file (org-roam-node-file (zetteldesk-ref-roam-node-read* (zetteldesk-ref-node-from-refs) nil #'zetteldesk-node-p))))

     (defun zetteldesk-ref-ivy-bibtex-with-notes (&optional arg)
       "Search `zetteldesk-desktop' BibTeX entries with notes using `ivy-bibtex'.

     This function builds on `ivy-bibtex-with-notes', meaning it shows
     a list of bibtex entries with notes, however its filtering
     includes only nodes in the `zetteldesk-desktop'.

     With a prefix ARG the cache is invalidated and the bibliography
     reread."
       (interactive "P")
       (cl-letf* ((candidates (zetteldesk-ref-note-refs-p))
		  ((symbol-function 'bibtex-completion-candidates)
		   (lambda ()
		     (cl-loop for ref in candidates
			      if (member (concat "cite:" (cdr (assoc "=key=" ref)))
					 (zetteldesk-ref-citekey-from-node))
			      collect ref))))
	 (ivy-bibtex arg)))

     (defun zetteldesk-ref-helm-bibtex-with-notes (&optional arg)
       "Search `zetteldesk-desktop' BibTeX entries with notes using `helm-bibtex'.

     This function builds on `helm-bibtex-with-notes', meaning it shows
     a list of bibtex entries with notes, however its filtering
     includes only nodes in the `zetteldesk-desktop'.

     With a prefix ARG the cache is invalidated and the bibliography
     reread."
       (interactive "P")
       (cl-letf* ((candidates (zetteldesk-ref-note-refs-p))
		  ((symbol-function 'bibtex-completion-candidates)
		   (lambda ()
		     (cl-loop for ref in candidates
			      if (member (concat "cite:" (cdr (assoc "=key=" ref)))
					 (zetteldesk-ref-citekey-from-node))
			      collect ref))))
	 (helm-bibtex arg)))

     (defun zetteldesk-ref-insert-ref-node-contents (&optional arg)
       "Select a node that is part of the current `zetteldesk-desktop' and a ref node.
     Ref nodes are nodes that refer to reference material such as an
     article.  These are gathered with `zetteldesk-ref-node-from-refs' and
     shown to the user through `zetteldesk-ref-roam-node-read*' filtered
     according to `zetteldesk-node-p'.

     After selection, in the location determined by
     `zetteldesk-insert-location' (typically *zetteldesk-scratch*), go
     to `point-max', insert a newline and then insert the contents of
     the selected node but remove the first 4 lines which is the
     unneeded property drawer.  After, indent all headings by one level
     and replace the #+title: with an asterisk.  Finally, enter a
     newline after the title, where the string \"Bibtex entry for
     node: \" is entered suffixed by the citekey of the entry.

     If given the optional argument ARG, which needs to be the
     `\\[universal-argument]' also switch to the *zetteldesk-scratch*
     buffer in a split. If given `\\[universal-argument]'
     `\\[universal-argument]' also insert the citekey in the current
     buffer. In `zetteldesk-insert-node-contents', inserting a link to
     the node is the default behaviour and a seperate function is
     implemented for when you don't want that. In this version, it
     made more sense to order it this way in my opinion."
       (interactive "P")
       (let* ((node
	       (zetteldesk-ref-roam-node-read* (zetteldesk-ref-node-from-refs) nil #'zetteldesk-node-p))
	      (file (org-roam-node-file node))
	      (location (zetteldesk-insert-location))
	      (citekey (concat "cite:" (car (org-roam-node-refs node)))))
	 (when (equal arg '(16))
	   (insert citekey))
	 (set-buffer location)
	 (goto-char (point-max))
	 (save-excursion
	   (insert-file-contents file))
	 (kill-whole-line 4)
	 (newline)
	 (save-excursion
	   (while (not (org-next-visible-heading 1))
	     (org-metaright)))
	 (zetteldesk--replace-title)
	 (end-of-line 1)
	 (newline)
	 (insert "Bibtex entry for node: "
		 citekey))
       (zetteldesk-insert-switch-to-scratch arg))

   #+END_SRC

   #+RESULTS:
   : zetteldesk-ref-insert-ref-node-contents

** Using Citar as a backend for zetteldesk-ref
With the help of bdarcus, the author of Citar (check discussion in [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/issues/5][issue]]) I have managed to implement zetteldesk-ref's features with Citar. This section is the code needed for that tangled to zetteldesk-ref-citar.

#+BEGIN_SRC elisp :tangle zetteldesk-ref-citar.el
  ;;; zetteldesk-ref-citar.el --- A zetteldesk extension for interfacing with literature nodes  -*- lexical-binding: t; -*-

  ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
  ;; Maintainer: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
  ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk-ref-citar.el
  ;; Package-Requires: ((zetteldesk "1.0") (citar "0.9") (emacs "26.1"))
  ;; Created: 27th March 2022
  ;; License: GPL-3.0
  ;; Version: 0.2

  ;; This file is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; For a full copy of the GNU General Public License
  ;; see <https://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; This package provides some optional improvements to zetteldesk.el.
  ;; Specifically it introduces mechanisms for handling literature notes
  ;; associated to a bibtex entry which are mostly powered by org-noter.
  ;; This code makes these reference materials interface better with the
  ;; zetteldesk. The original zetteldesk-ref package uses the
  ;; bibtex-completion package as its backend which is what I currently
  ;; use. However, Citar is another great package for managing
  ;; bibliography so I decided to port that package to work with Citar
  ;; as well.

  ;;; Code:

  (require 'zetteldesk)
  (require 'citar)
  (require 'citar-org-roam)
#+END_SRC

#+BEGIN_SRC elisp :tangle zetteldesk-ref-citar.el

  (defun zetteldesk-ref-citar-node-from-refs ()
    "Collects a list of ref nodes.

  The function `citar-org-roam-keys-with-notes' returns a list of
  citekeys which have an `org-roam-node' associated to them and
  through `org-roam-node-from-ref', the function returns the list
  of those nodes."
    (cl-loop for cand in (citar-org-roam-keys-with-notes)
	     collect (org-roam-node-from-ref (concat "@" cand))))

  (defun zetteldesk-ref-citar-citekey-from-node ()
    "Collects the citekeys of org-roam-nodes in the `zetteldesk-desktop'.

  Ignores nodes for which `org-roam-node-refs' returns nil."
    (let* ((init-list (org-roam-node-list))
	   (zetteldesk-nodes (cl-remove-if-not #'zetteldesk-node-p init-list)))
      (cl-loop for node in zetteldesk-nodes
	       if (org-roam-node-refs node)
	       collect (car (org-roam-node-refs node)))))

  (defun zetteldesk-ref-citar-key-from-node ()
    "Remove the \"cite:\" prefix from a list of citekeys in `zetteldesk-desktop'.

  The list is the one that `zetteldesk-ref-citar-citekey-from-node'
  collects, however, since Citar functions expect the citekeys to
  not have this prefix, this function takes that list and removes
  that prefix from the citekeys."
    (cl-loop for ref in (zetteldesk-ref-citar-citekey-from-node)
	     collect (string-remove-prefix "cite:" ref)))

  (defun zetteldesk-ref-citar-roam-node-read--completions* (node-list &optional filter-fn sort-fn)
    "Run `org-roam-node-read--completions' with NODE-LIST being a list of nodes.

  Typically, the function takes `org-roam-node-list' as the initial
  list of nodes and creates the alist `org-roam-node-read'
  uses.  However, it can be helpful to supply the list of nodes
  yourself, when the predicate function used cannot be inferred
  through a filter function of the form this function
  takes.  FILTER-FN and SORT-FN are the same as in
  `org-roam-node-read--completions'.  The resulting alist is to be
  used with `org-roam-node-read*'."
    (let* ((template (org-roam-node--process-display-format org-roam-node-display-template))
	   (nodes node-list)
	   (nodes (mapcar (lambda (node)
			    (org-roam-node-read--to-candidate node template)) nodes))
	   (nodes (if filter-fn
		      (cl-remove-if-not
		       (lambda (n) (funcall filter-fn (cdr n)))
		       nodes)
		    nodes))
	   (sort-fn (or sort-fn
			(when org-roam-node-default-sort
			  (intern (concat "org-roam-node-read-sort-by-"
					  (symbol-name org-roam-node-default-sort))))))
	   (nodes (if sort-fn (seq-sort sort-fn nodes)
		    nodes)))
      nodes))

  (defun zetteldesk-ref-citar-roam-node-read* (node-list &optional initial-input filter-fn sort-fn require-match prompt)
    "Run `org-roam-node-read' with the nodes supplied by NODE-LIST.

  NODE-LIST is a list of nodes passed to
  `zetteldesk-ref-citar-roam-node-read--completions*', which creates an alist of
  nodes with the proper formatting to be used in this
  function.  This is for those cases where it is helpful to use your
  own list of nodes, because a predicate function can not filter
  them in the way you want easily.

  INITIAL-INPUT, SORT-FN, FILTER-FN, REQUIRE-MATCH, PROMPT are the
  same as in `org-roam-node-read'."
    (let* ((nodes (zetteldesk-ref-citar-roam-node-read--completions* node-list filter-fn sort-fn))
	   (prompt (or prompt "Node: "))
	   (node (completing-read
		  prompt
		  (lambda (string pred action)
		    (if (eq action 'metadata)
			`(metadata
			  ;; Preserve sorting in the completion UI if a sort-fn is used
			  ,@(when sort-fn
			      '((display-sort-function . identity)
				(cycle-sort-function . identity)))
			  (annotation-function
			   . ,(lambda (title)
				(funcall org-roam-node-annotation-function
					 (get-text-property 0 'node title))))
			  (category . org-roam-node))
		      (complete-with-action action nodes string pred)))
		  nil require-match initial-input 'org-roam-node-history)))
      (or (cdr (assoc node nodes))
	  (org-roam-node-create :title node))))

  (defun zetteldesk-ref-citar-add-node-to-desktop (NODE)
    "Add NODE to the `zetteldesk-desktop'.

  NODE is a literature note that is part of the org-roam
  repository.  The list of such nodes is gathered with
  `zetteldesk-ref-citar-node-from-refs'."
    (interactive (list (zetteldesk-ref-citar-roam-node-read* (zetteldesk-ref-citar-node-from-refs))))
    (let ((buffer (org-roam-node-buffer NODE))
	  (file (org-roam-node-file NODE))
	  (org-startup-with-latex-preview nil))
      (if buffer
	  (zetteldesk--add-buffer buffer)
	(zetteldesk--add-buffer (find-file-noselect file)))))

  (defun zetteldesk-ref-citar-remove-node-from-desktop (NODE)
    "Remove NODE from the `zetteldesk-desktop'.

  NODE is a literature note that is currently part of the
  zetteldesk, meaning its part of the list generated by
  `zetteldesk-ref-citar-node-from-refs'."
    (interactive
     (list (zetteldesk-ref-roam-node-read* (zetteldesk-ref-citar-node-from-refs) nil #'zetteldesk-node-p)))
    (let ((buffer (org-roam-node-buffer NODE)))
      (zetteldesk--remove-buffer buffer)))

  (defun zetteldesk-ref-citar-find-ref-node ()
    "Execute a filtered version of `citar-open-notes' in an org-roam UI.

   It collects a list of nodes which are reference nodes linked to
  a bibtex entry through `zetteldesk-ref-citar-node-from-refs' and passes
  it to `zetteldesk-ref-roam-node-read*' which is a modified
  version of `org-roam-node-read' which takes a list of nodes as an
  argument.  Since this required a rewrite of `org-roam-node-read',
  finding the file is done indirectly and not through
  `org-roam-node-file'."
    (interactive)
    (find-file (org-roam-node-file (zetteldesk-ref-roam-node-read* (zetteldesk-ref-citar-node-from-refs) nil #'zetteldesk-node-p))))

  (defun zetteldesk-ref-citar-open-note ()
    "Execute a filtered version of `citar-open-notes' in its own UI.

  The list of keys that `citar-get-notes' requires for this is
  collected through `zetteldesk-ref-citar-key-from-node' and the
  rest of the code functions just like the interactive version of
  `citar-open-notes'."
    (interactive (list (when-let* ((notes (citar-get-notes (zetteldesk-ref-citar-key-from-node)))
				   (allnotes (delete-dups (apply #'append (hash-table-values notes)))))
			 (cdr (citar--select-resource nil :notes allnotes))))))

  (defun zetteldesk-ref-citar-insert-ref-node-contents (&optional arg)
    "Select a node that is part of the current `zetteldesk-desktop' and a ref node.

  Ref nodes are nodes that refer to reference material such as an
  article.  These are gathered with `zetteldesk-ref-citar-node-from-refs' and
  shown to the user through `zetteldesk-ref-citar-roam-node-read*' filtered
  according to `zetteldesk-node-p'.

  After selection, in the location determined by
  `zetteldesk-insert-location' (typically *zetteldesk-scratch*), go
  to `point-max', insert a newline and then insert the contents of
  the selected node but remove the first 4 lines which is the
  unneeded property drawer.  After, indent all headings by one level
  and replace the #+title: with an asterisk.  Finally, enter a
  newline after the title, where the string \"Bibtex entry for
  node: \" is entered suffixed by the citekey of the entry.

  If given the optional argument ARG, which needs to be the
  `\\[universal-argument]' also switch to the *zetteldesk-scratch*
  buffer in a split. If given `\\[universal-argument]'
  `\\[universal-argument]' also insert the citekey in the current
  buffer. In `zetteldesk-insert-node-contents', inserting a link to
  the node is the default behaviour and a seperate function is
  implemented for when you don't want that. In this version, it
  made more sense to order it this way in my opinion."
    (interactive "P")
    (let* ((node
	    (zetteldesk-ref-roam-node-read* (zetteldesk-ref-citar-node-from-refs) nil #'zetteldesk-node-p))
	   (file (org-roam-node-file node))
	   (location (zetteldesk-insert-location))
	   (citekey (concat "cite:" (car (org-roam-node-refs node)))))
      (when (equal arg '(16))
	(insert citekey))
      (set-buffer location)
      (goto-char (point-max))
      (save-excursion
	(insert-file-contents file))
      (kill-whole-line 4)
      (newline)
      (save-excursion
	(while (not (org-next-visible-heading 1))
	  (org-metaright)))
      (zetteldesk--replace-title)
      (end-of-line 1)
      (newline)
      (insert "Bibtex entry for node: "
	      citekey))
    (zetteldesk-insert-switch-to-scratch arg))
  
#+END_SRC

#+RESULTS:
: zetteldesk-ref-citar-insert-ref-node-contents
   
* Info Nodes
    The info buffer is a single persistent buffer. Therefore, the typical things done in the zetteldesk don't work here. This section is an attempt to fix this and use info nodes together with zetteldesk. There is a function that gives the nodes name in a format that all other Info functions accept. I use that function and add the nodes selected to a variable. The rest of the functions, choose something from that list with completing-read and that is how this system works. For example, the removing mechanisms works by using remove with its argument being the output of the completing-read. The insertion function is a function that prompts the user to select an info buffer that is part of the zetteldesk and inserts its contents to the zetteldesk-scratch buffer under a similarly to above formatted heading. Furthermore, it inserts a link to the info node so you can see it in its context. 

** Preamble
    This is just the intro text that needs to be in the start of the file

    #+BEGIN_SRC elisp :tangle zetteldesk-info.el
      ;;; zetteldesk-info.el --- A zetteldesk extension for interacting with the info program   -*- lexical-binding: t; -*-

      ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
      ;; Maintainer: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
      ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk-info.el
      ;; Package-Requires: ((zetteldesk "0.4") (emacs "27.1"))
      ;; Created: 6th April 2022
      ;; License: GPL-3.0
      ;; Version: 0.2

      ;; This file is free software; you can redistribute it and/or modify
      ;; it under the terms of the GNU General Public License as published by
      ;; the Free Software Foundation; either version 3, or (at your option)
      ;; any later version.

      ;; This program is distributed in the hope that it will be useful,
      ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
      ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      ;; GNU General Public License for more details.

      ;; For a full copy of the GNU General Public License
      ;; see <https://www.gnu.org/licenses/>.

      ;;; Commentary:

      ;; This package provides some optional improvements to zetteldesk.el.
      ;; Specifically it introduces mechanisms for handling nodes from the
      ;; Info program built in to Emacs, which isn't trivial as its a
      ;; persistent buffer and so the typical predicates used are not
      ;; available for use here

      ;;; Code:

      (require 'zetteldesk)

    #+END_SRC

** The rest of the code

    #+BEGIN_SRC elisp :tangle zetteldesk-info.el

      ;; -- Info Nodes --
      (defcustom zetteldesk-info-nodes '()
	"List of info nodes that are part of the zetteldesk.
      Initialised as an empty list"
	:type 'list
	:group 'zetteldesk)

      (defun zetteldesk-info-add-info-node-to-desktop ()
	"Find the current info-node.
      Then add its name to the list of the variable
      `zetteldesk-info-nodes'"
	(interactive)
	(add-to-list 'zetteldesk-info-nodes (Info-copy-current-node-name)))

      (defun zetteldesk-info-remove-info-node-from-desktop ()
	"Remove an info-node from the `zetteldesk-desktop'.
      The node is selected through a `completing-read' menu of
      `zetteldesk-info-nodes'"
	(interactive)
	(setq zetteldesk-info-nodes (remove
				     (completing-read "Info Nodes: " zetteldesk-info-nodes)
				     zetteldesk-info-nodes)))

      (defun zetteldesk-info-goto-node ()
	"Zetteldesk filter function for `Info-goto-node'.

      Prompts the user to select a node from the list
      `zetteldesk-info-nodes' and jumps to that node"
	(interactive)
	(Info-goto-node (completing-read "Nodes: " zetteldesk-info-nodes)))

      (defun zetteldesk-info-insert-contents (&optional arg)
	"Select an info node that is part of the current `zetteldesk-desktop'.
      Uses a `completing-read' prompt for the selection.

      Then, in the *zetteldesk-scratch* buffer, go to the end of the
      buffer, insert a newline and a heading of the form \"Supportive
      Material - \" the node's name \"(Info)\" akin to what is done in
      `zetteldesk-insert-link-to-pdf'.  Then, insert the contents of the
      chosen info node, removing the first 2 lines which have the
      contextual links of the buffer, as they are not functional
      outside of the info buffer.  Also insert a link with the title
      \"See this node in its context\" which opens the node inside the
      info program. Finally, restore the buffer from which this
      function was called. Ideally, this wouldn't require a
      switch-to-buffer statement, but the function `Info-goto-node'
      used for this function switches the visible buffer to the info
      node and I couldn't find an alternative that only makes it
      current for editing operations, but doesn't change the visible
      buffer to it.

      I find the link to the actual info buffer is useful as a lot of
      the time, you might want to insert the buffer so you can store it
      with other useful information inside the zetteldesk-scratch
      buffer, but then, you are interested in looking into the other
      nodes of the manual you were reading.

      Optional argument ARG which is a `\\[universal-argument]' switch to the
      zetteldesk-scratch buffer in a split."
	(interactive "P")
	(let ((info_node (completing-read "Nodes: " zetteldesk-info-nodes))
	      (location (zetteldesk-insert-location))
	      (buffer (current-buffer)))
	  (Info-goto-node info_node)
	  (with-current-buffer location
	    (goto-char (point-max))
	    (newline)
	    (org-insert-heading)
	    (insert "Supportive Material - " info_node " (Info)")
	    (newline)
	    (save-excursion (insert-buffer-substring "*info*")
			    (insert
			     (org-link-make-string
			      (concat "elisp:(Info-goto-node \"" info_node "\")")
			      "See this node in its context")))
	    (kill-whole-line 2))
	  (switch-to-buffer buffer)
	  (zetteldesk-insert-switch-to-scratch arg)))

    #+END_SRC

    #+RESULTS:
    : zetteldesk-insert-info-contents

* COMMENT Adding keybindings to the hydra
For my package zetteldesk.el, I define some keybindings in the file zetteldesk-kb.el. As I do not use these keybindings myself (I prefer the evil-styled ones that suit my config better tbh) that file is never loaded in my config, therefore this should also not be loaded. However, as I often play around with the code here and not in the zetteldesk directory I want to have this here for copy-paste-ability.

#+BEGIN_SRC elisp :tangle zetteldesk-kb.el

  ;; -- Zetteldesk-ref.el --

  (with-eval-after-load 'zetteldesk-ref
    (pretty-hydra-define+ zetteldesk-insert-hydra ()
      ("Org-Roam"
       (("r" zetteldesk-ref-insert-ref-node-contents "Link to citekey and Node Contents in *zetteldesk-scratch with special formatting")))))

  (with-eval-after-load 'zetteldesk-ref
    (pretty-hydra-define zetteldesk-literature-hydra (:color blue :title "Zetteldesk Literature Nodes")
      ("Org-Roam UI"
       (("r" zetteldesk-ref-find-ref-node))

       "Helm-Bibtex UI"
       (("h" zetteldesk-ref-helm-bibtex-with-notes))

       "Ivy-Bibtex UI"
       (("i" zetteldesk-ref-ivy-bibtex-with-notes)))))

  (with-eval-after-load 'zetteldesk-ref
    (pretty-hydra-define+ zetteldesk-add-hydra ()
      ("Org-Roam"
       (("l" zetteldesk-ref-add-node-to-desktop "Add Literature Node")))))

  (with-eval-after-load 'zetteldesk-ref
    (pretty-hydra-define+ zetteldesk-remove-hydra ()
      ("Org-Roam"
       (("l" zetteldesk-ref-remove-node-from-desktop "Remove Literature Node")))))

  (with-eval-after-load 'zetteldesk-ref
    (pretty-hydra-define+ zetteldesk-main-hydra ()
      ("Filter Functions"
       (("l" zetteldesk-literature-hydra/body "Go to Zetteldesk Literature Node")))))

#+END_SRC

#+RESULTS:
: zetteldesk-main-hydra/body

#+BEGIN_SRC elisp :tangle zetteldesk-kb.el

  ;; -- Zetteldesk-info.el --

  (with-eval-after-load 'zetteldesk-info
    (pretty-hydra-define+ zetteldesk-add-hydra ()
      ("Other"
       (("i" zetteldesk-info-add-info-node-to-desktop "Add Info Node")))))

  (with-eval-after-load 'zetteldesk-info
    (pretty-hydra-define+ zetteldesk-remove-hydra ()
      ("Other"
       (("i" zetteldesk-info-remove-info-node-from-desktop "Remove Info Node")))))

  (with-eval-after-load 'zetteldesk-info
    (pretty-hydra-define+ zetteldesk-main-hydra ()
      ("Filter Functions"
       (("I" zetteldesk-info-goto-node "Go to Zetteldesk Info Node")))))

  (with-eval-after-load 'zetteldesk-info
    (pretty-hydra-define+ zetteldesk-insert-hydra ()
      ("Supplementary Material to *zetteldesk-scratch*"
       (("I" zetteldesk-info-insert-contents "Info Node Contents + Link to context")))))
#+END_SRC

* Providing the packages to be loaded in init.el
#+BEGIN_SRC elisp :tangle zetteldesk.el

  (provide 'zetteldesk)
  ;;; zetteldesk.el ends here

#+END_SRC
  
#+BEGIN_SRC elisp :tangle zetteldesk-ref.el

  (provide 'zetteldesk-ref)
  ;;; zetteldesk-ref.el ends here

#+END_SRC

#+BEGIN_SRC elisp :tangle zetteldesk-info.el

    (provide 'zetteldesk-info)
    ;;; zetteldesk-info.el ends here
#+END_SRC

#+BEGIN_SRC elisp :tangle zetteldesk-remark.el

  (provide 'zetteldesk-remark)
  ;;; zetteldesk-remark.el ends here
#+END_SRC

#+BEGIN_SRC elisp :tangle zetteldesk-kb.el

  (provide 'zetteldesk-kb)
  ;;; zetteldesk-kb.el ends here

#+END_SRC

#+BEGIN_SRC elisp :tangle zetteldesk-ref-citar.el

  (provide 'zetteldesk-ref-citar)
  ;;; zetteldesk-ref-citar.el ends here
#+END_SRC
